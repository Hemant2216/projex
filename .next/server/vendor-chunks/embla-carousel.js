"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/embla-carousel";
exports.ids = ["vendor-chunks/embla-carousel"];
exports.modules = {

/***/ "(ssr)/./node_modules/embla-carousel/esm/embla-carousel.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/embla-carousel/esm/embla-carousel.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EmblaCarousel)\n/* harmony export */ });\nfunction isNumber(subject) {\n    return typeof subject === \"number\";\n}\nfunction isString(subject) {\n    return typeof subject === \"string\";\n}\nfunction isBoolean(subject) {\n    return typeof subject === \"boolean\";\n}\nfunction isObject(subject) {\n    return Object.prototype.toString.call(subject) === \"[object Object]\";\n}\nfunction mathAbs(n) {\n    return Math.abs(n);\n}\nfunction mathSign(n) {\n    return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n    return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n    if (valueB === 0 || valueA === 0) return 0;\n    if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n    const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n    return mathAbs(diff / valueB);\n}\nfunction arrayKeys(array) {\n    return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n    return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n    return Math.max(0, array.length - 1);\n}\nfunction arrayIsLastIndex(array, index) {\n    return index === arrayLastIndex(array);\n}\nfunction arrayFromNumber(n, startAt = 0) {\n    return Array.from(Array(n), (_, i)=>startAt + i);\n}\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n    return [\n        objectA,\n        objectB\n    ].reduce((mergedObjects, currentObject)=>{\n        objectKeys(currentObject).forEach((key)=>{\n            const valueA = mergedObjects[key];\n            const valueB = currentObject[key];\n            const areObjects = isObject(valueA) && isObject(valueB);\n            mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n        });\n        return mergedObjects;\n    }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n    return typeof ownerWindow.MouseEvent !== \"undefined\" && evt instanceof ownerWindow.MouseEvent;\n}\nfunction Alignment(align, viewSize) {\n    const predefined = {\n        start,\n        center,\n        end\n    };\n    function start() {\n        return 0;\n    }\n    function center(n) {\n        return end(n) / 2;\n    }\n    function end(n) {\n        return viewSize - n;\n    }\n    function measure(n, index) {\n        if (isString(align)) return predefined[align](n);\n        return align(viewSize, n, index);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction EventStore() {\n    let listeners = [];\n    function add(node, type, handler, options = {\n        passive: true\n    }) {\n        let removeListener;\n        if (\"addEventListener\" in node) {\n            node.addEventListener(type, handler, options);\n            removeListener = ()=>node.removeEventListener(type, handler, options);\n        } else {\n            const legacyMediaQueryList = node;\n            legacyMediaQueryList.addListener(handler);\n            removeListener = ()=>legacyMediaQueryList.removeListener(handler);\n        }\n        listeners.push(removeListener);\n        return self;\n    }\n    function clear() {\n        listeners = listeners.filter((remove)=>remove());\n    }\n    const self = {\n        add,\n        clear\n    };\n    return self;\n}\nfunction Animations(ownerDocument, ownerWindow, update, render) {\n    const documentVisibleHandler = EventStore();\n    const timeStep = 1000 / 60;\n    let lastTimeStamp = null;\n    let lag = 0;\n    let animationFrame = 0;\n    function init() {\n        documentVisibleHandler.add(ownerDocument, \"visibilitychange\", ()=>{\n            if (ownerDocument.hidden) reset();\n        });\n    }\n    function destroy() {\n        stop();\n        documentVisibleHandler.clear();\n    }\n    function animate(timeStamp) {\n        if (!animationFrame) return;\n        if (!lastTimeStamp) lastTimeStamp = timeStamp;\n        const elapsed = timeStamp - lastTimeStamp;\n        lastTimeStamp = timeStamp;\n        lag += elapsed;\n        while(lag >= timeStep){\n            update(timeStep);\n            lag -= timeStep;\n        }\n        const lagOffset = lag / timeStep;\n        render(lagOffset);\n        if (animationFrame) ownerWindow.requestAnimationFrame(animate);\n    }\n    function start() {\n        if (animationFrame) return;\n        animationFrame = ownerWindow.requestAnimationFrame(animate);\n    }\n    function stop() {\n        ownerWindow.cancelAnimationFrame(animationFrame);\n        lastTimeStamp = null;\n        lag = 0;\n        animationFrame = 0;\n    }\n    function reset() {\n        lastTimeStamp = null;\n        lag = 0;\n    }\n    const self = {\n        init,\n        destroy,\n        start,\n        stop,\n        update: ()=>update(timeStep),\n        render\n    };\n    return self;\n}\nfunction Axis(axis, contentDirection) {\n    const isRightToLeft = contentDirection === \"rtl\";\n    const isVertical = axis === \"y\";\n    const scroll = isVertical ? \"y\" : \"x\";\n    const cross = isVertical ? \"x\" : \"y\";\n    const sign = !isVertical && isRightToLeft ? -1 : 1;\n    const startEdge = getStartEdge();\n    const endEdge = getEndEdge();\n    function measureSize(nodeRect) {\n        const { height, width } = nodeRect;\n        return isVertical ? height : width;\n    }\n    function getStartEdge() {\n        if (isVertical) return \"top\";\n        return isRightToLeft ? \"right\" : \"left\";\n    }\n    function getEndEdge() {\n        if (isVertical) return \"bottom\";\n        return isRightToLeft ? \"left\" : \"right\";\n    }\n    function direction(n) {\n        return n * sign;\n    }\n    const self = {\n        scroll,\n        cross,\n        startEdge,\n        endEdge,\n        measureSize,\n        direction\n    };\n    return self;\n}\nfunction Limit(min = 0, max = 0) {\n    const length = mathAbs(min - max);\n    function reachedMin(n) {\n        return n < min;\n    }\n    function reachedMax(n) {\n        return n > max;\n    }\n    function reachedAny(n) {\n        return reachedMin(n) || reachedMax(n);\n    }\n    function constrain(n) {\n        if (!reachedAny(n)) return n;\n        return reachedMin(n) ? min : max;\n    }\n    function removeOffset(n) {\n        if (!length) return n;\n        return n - length * Math.ceil((n - max) / length);\n    }\n    const self = {\n        length,\n        max,\n        min,\n        constrain,\n        reachedAny,\n        reachedMax,\n        reachedMin,\n        removeOffset\n    };\n    return self;\n}\nfunction Counter(max, start, loop) {\n    const { constrain } = Limit(0, max);\n    const loopEnd = max + 1;\n    let counter = withinLimit(start);\n    function withinLimit(n) {\n        return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n    }\n    function get() {\n        return counter;\n    }\n    function set(n) {\n        counter = withinLimit(n);\n        return self;\n    }\n    function add(n) {\n        return clone().set(get() + n);\n    }\n    function clone() {\n        return Counter(max, get(), loop);\n    }\n    const self = {\n        get,\n        set,\n        add,\n        clone\n    };\n    return self;\n}\nfunction DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {\n    const { cross: crossAxis, direction } = axis;\n    const focusNodes = [\n        \"INPUT\",\n        \"SELECT\",\n        \"TEXTAREA\"\n    ];\n    const nonPassiveEvent = {\n        passive: false\n    };\n    const initEvents = EventStore();\n    const dragEvents = EventStore();\n    const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n    const snapForceBoost = {\n        mouse: 300,\n        touch: 400\n    };\n    const freeForceBoost = {\n        mouse: 500,\n        touch: 600\n    };\n    const baseSpeed = dragFree ? 43 : 25;\n    let isMoving = false;\n    let startScroll = 0;\n    let startCross = 0;\n    let pointerIsDown = false;\n    let preventScroll = false;\n    let preventClick = false;\n    let isMouse = false;\n    function init(emblaApi) {\n        if (!watchDrag) return;\n        function downIfAllowed(evt) {\n            if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);\n        }\n        const node = rootNode;\n        initEvents.add(node, \"dragstart\", (evt)=>evt.preventDefault(), nonPassiveEvent).add(node, \"touchmove\", ()=>undefined, nonPassiveEvent).add(node, \"touchend\", ()=>undefined).add(node, \"touchstart\", downIfAllowed).add(node, \"mousedown\", downIfAllowed).add(node, \"touchcancel\", up).add(node, \"contextmenu\", up).add(node, \"click\", click, true);\n    }\n    function destroy() {\n        initEvents.clear();\n        dragEvents.clear();\n    }\n    function addDragEvents() {\n        const node = isMouse ? ownerDocument : rootNode;\n        dragEvents.add(node, \"touchmove\", move, nonPassiveEvent).add(node, \"touchend\", up).add(node, \"mousemove\", move, nonPassiveEvent).add(node, \"mouseup\", up);\n    }\n    function isFocusNode(node) {\n        const nodeName = node.nodeName || \"\";\n        return focusNodes.includes(nodeName);\n    }\n    function forceBoost() {\n        const boost = dragFree ? freeForceBoost : snapForceBoost;\n        const type = isMouse ? \"mouse\" : \"touch\";\n        return boost[type];\n    }\n    function allowedForce(force, targetChanged) {\n        const next = index.add(mathSign(force) * -1);\n        const baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n        if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;\n        if (skipSnaps && targetChanged) return baseForce * 0.5;\n        return scrollTarget.byIndex(next.get(), 0).distance;\n    }\n    function down(evt) {\n        const isMouseEvt = isMouseEvent(evt, ownerWindow);\n        isMouse = isMouseEvt;\n        preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n        isMoving = deltaAbs(target.get(), location.get()) >= 2;\n        if (isMouseEvt && evt.button !== 0) return;\n        if (isFocusNode(evt.target)) return;\n        pointerIsDown = true;\n        dragTracker.pointerDown(evt);\n        scrollBody.useFriction(0).useDuration(0);\n        target.set(location);\n        addDragEvents();\n        startScroll = dragTracker.readPoint(evt);\n        startCross = dragTracker.readPoint(evt, crossAxis);\n        eventHandler.emit(\"pointerDown\");\n    }\n    function move(evt) {\n        const isTouchEvt = !isMouseEvent(evt, ownerWindow);\n        if (isTouchEvt && evt.touches.length >= 2) return up(evt);\n        const lastScroll = dragTracker.readPoint(evt);\n        const lastCross = dragTracker.readPoint(evt, crossAxis);\n        const diffScroll = deltaAbs(lastScroll, startScroll);\n        const diffCross = deltaAbs(lastCross, startCross);\n        if (!preventScroll && !isMouse) {\n            if (!evt.cancelable) return up(evt);\n            preventScroll = diffScroll > diffCross;\n            if (!preventScroll) return up(evt);\n        }\n        const diff = dragTracker.pointerMove(evt);\n        if (diffScroll > dragThreshold) preventClick = true;\n        scrollBody.useFriction(0.3).useDuration(0.75);\n        animation.start();\n        target.add(direction(diff));\n        evt.preventDefault();\n    }\n    function up(evt) {\n        const currentLocation = scrollTarget.byDistance(0, false);\n        const targetChanged = currentLocation.index !== index.get();\n        const rawForce = dragTracker.pointerUp(evt) * forceBoost();\n        const force = allowedForce(direction(rawForce), targetChanged);\n        const forceFactor = factorAbs(rawForce, force);\n        const speed = baseSpeed - 10 * forceFactor;\n        const friction = baseFriction + forceFactor / 50;\n        preventScroll = false;\n        pointerIsDown = false;\n        dragEvents.clear();\n        scrollBody.useDuration(speed).useFriction(friction);\n        scrollTo.distance(force, !dragFree);\n        isMouse = false;\n        eventHandler.emit(\"pointerUp\");\n    }\n    function click(evt) {\n        if (preventClick) {\n            evt.stopPropagation();\n            evt.preventDefault();\n            preventClick = false;\n        }\n    }\n    function pointerDown() {\n        return pointerIsDown;\n    }\n    const self = {\n        init,\n        destroy,\n        pointerDown\n    };\n    return self;\n}\nfunction DragTracker(axis, ownerWindow) {\n    const logInterval = 170;\n    let startEvent;\n    let lastEvent;\n    function readTime(evt) {\n        return evt.timeStamp;\n    }\n    function readPoint(evt, evtAxis) {\n        const property = evtAxis || axis.scroll;\n        const coord = `client${property === \"x\" ? \"X\" : \"Y\"}`;\n        return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n    }\n    function pointerDown(evt) {\n        startEvent = evt;\n        lastEvent = evt;\n        return readPoint(evt);\n    }\n    function pointerMove(evt) {\n        const diff = readPoint(evt) - readPoint(lastEvent);\n        const expired = readTime(evt) - readTime(startEvent) > logInterval;\n        lastEvent = evt;\n        if (expired) startEvent = evt;\n        return diff;\n    }\n    function pointerUp(evt) {\n        if (!startEvent || !lastEvent) return 0;\n        const diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n        const diffTime = readTime(evt) - readTime(startEvent);\n        const expired = readTime(evt) - readTime(lastEvent) > logInterval;\n        const force = diffDrag / diffTime;\n        const isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n        return isFlick ? force : 0;\n    }\n    const self = {\n        pointerDown,\n        pointerMove,\n        pointerUp,\n        readPoint\n    };\n    return self;\n}\nfunction NodeRects() {\n    function measure(node) {\n        const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node;\n        const offset = {\n            top: offsetTop,\n            right: offsetLeft + offsetWidth,\n            bottom: offsetTop + offsetHeight,\n            left: offsetLeft,\n            width: offsetWidth,\n            height: offsetHeight\n        };\n        return offset;\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction PercentOfView(viewSize) {\n    function measure(n) {\n        return viewSize * (n / 100);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {\n    const observeNodes = [\n        container\n    ].concat(slides);\n    let resizeObserver;\n    let containerSize;\n    let slideSizes = [];\n    let destroyed = false;\n    function readSize(node) {\n        return axis.measureSize(nodeRects.measure(node));\n    }\n    function init(emblaApi) {\n        if (!watchResize) return;\n        containerSize = readSize(container);\n        slideSizes = slides.map(readSize);\n        function defaultCallback(entries) {\n            for (const entry of entries){\n                if (destroyed) return;\n                const isContainer = entry.target === container;\n                const slideIndex = slides.indexOf(entry.target);\n                const lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n                const newSize = readSize(isContainer ? container : slides[slideIndex]);\n                const diffSize = mathAbs(newSize - lastSize);\n                if (diffSize >= 0.5) {\n                    emblaApi.reInit();\n                    eventHandler.emit(\"resize\");\n                    break;\n                }\n            }\n        }\n        resizeObserver = new ResizeObserver((entries)=>{\n            if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n                defaultCallback(entries);\n            }\n        });\n        ownerWindow.requestAnimationFrame(()=>{\n            observeNodes.forEach((node)=>resizeObserver.observe(node));\n        });\n    }\n    function destroy() {\n        destroyed = true;\n        if (resizeObserver) resizeObserver.disconnect();\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {\n    let bodyVelocity = 0;\n    let scrollDirection = 0;\n    let scrollDuration = baseDuration;\n    let scrollFriction = baseFriction;\n    let rawLocation = location.get();\n    let rawLocationPrevious = 0;\n    function seek(timeStep) {\n        const fixedDeltaTimeSeconds = timeStep / 1000;\n        const duration = scrollDuration * fixedDeltaTimeSeconds;\n        const diff = target.get() - location.get();\n        const isInstant = !scrollDuration;\n        let directionDiff = 0;\n        if (isInstant) {\n            bodyVelocity = 0;\n            previousLocation.set(target);\n            location.set(target);\n            directionDiff = diff;\n        } else {\n            previousLocation.set(location);\n            bodyVelocity += diff / duration;\n            bodyVelocity *= scrollFriction;\n            rawLocation += bodyVelocity;\n            location.add(bodyVelocity * fixedDeltaTimeSeconds);\n            directionDiff = rawLocation - rawLocationPrevious;\n        }\n        scrollDirection = mathSign(directionDiff);\n        rawLocationPrevious = rawLocation;\n        return self;\n    }\n    function settled() {\n        const diff = target.get() - offsetLocation.get();\n        return mathAbs(diff) < 0.001;\n    }\n    function duration() {\n        return scrollDuration;\n    }\n    function direction() {\n        return scrollDirection;\n    }\n    function velocity() {\n        return bodyVelocity;\n    }\n    function useBaseDuration() {\n        return useDuration(baseDuration);\n    }\n    function useBaseFriction() {\n        return useFriction(baseFriction);\n    }\n    function useDuration(n) {\n        scrollDuration = n;\n        return self;\n    }\n    function useFriction(n) {\n        scrollFriction = n;\n        return self;\n    }\n    const self = {\n        direction,\n        duration,\n        velocity,\n        seek,\n        settled,\n        useBaseFriction,\n        useBaseDuration,\n        useFriction,\n        useDuration\n    };\n    return self;\n}\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n    const pullBackThreshold = percentOfView.measure(10);\n    const edgeOffsetTolerance = percentOfView.measure(50);\n    const frictionLimit = Limit(0.1, 0.99);\n    let disabled = false;\n    function shouldConstrain() {\n        if (disabled) return false;\n        if (!limit.reachedAny(target.get())) return false;\n        if (!limit.reachedAny(location.get())) return false;\n        return true;\n    }\n    function constrain(pointerDown) {\n        if (!shouldConstrain()) return;\n        const edge = limit.reachedMin(location.get()) ? \"min\" : \"max\";\n        const diffToEdge = mathAbs(limit[edge] - location.get());\n        const diffToTarget = target.get() - location.get();\n        const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n        target.subtract(diffToTarget * friction);\n        if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n            target.set(limit.constrain(target.get()));\n            scrollBody.useDuration(25).useBaseFriction();\n        }\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    const self = {\n        shouldConstrain,\n        constrain,\n        toggleActive\n    };\n    return self;\n}\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {\n    const scrollBounds = Limit(-contentSize + viewSize, 0);\n    const snapsBounded = measureBounded();\n    const scrollContainLimit = findScrollContainLimit();\n    const snapsContained = measureContained();\n    function usePixelTolerance(bound, snap) {\n        return deltaAbs(bound, snap) < 1;\n    }\n    function findScrollContainLimit() {\n        const startSnap = snapsBounded[0];\n        const endSnap = arrayLast(snapsBounded);\n        const min = snapsBounded.lastIndexOf(startSnap);\n        const max = snapsBounded.indexOf(endSnap) + 1;\n        return Limit(min, max);\n    }\n    function measureBounded() {\n        return snapsAligned.map((snapAligned, index)=>{\n            const { min, max } = scrollBounds;\n            const snap = scrollBounds.constrain(snapAligned);\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(snapsAligned, index);\n            if (isFirst) return max;\n            if (isLast) return min;\n            if (usePixelTolerance(min, snap)) return min;\n            if (usePixelTolerance(max, snap)) return max;\n            return snap;\n        }).map((scrollBound)=>parseFloat(scrollBound.toFixed(3)));\n    }\n    function measureContained() {\n        if (contentSize <= viewSize + pixelTolerance) return [\n            scrollBounds.max\n        ];\n        if (containScroll === \"keepSnaps\") return snapsBounded;\n        const { min, max } = scrollContainLimit;\n        return snapsBounded.slice(min, max);\n    }\n    const self = {\n        snapsContained,\n        scrollContainLimit\n    };\n    return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n    const max = scrollSnaps[0];\n    const min = loop ? max - contentSize : arrayLast(scrollSnaps);\n    const limit = Limit(min, max);\n    const self = {\n        limit\n    };\n    return self;\n}\nfunction ScrollLooper(contentSize, limit, location, vectors) {\n    const jointSafety = 0.1;\n    const min = limit.min + jointSafety;\n    const max = limit.max + jointSafety;\n    const { reachedMin, reachedMax } = Limit(min, max);\n    function shouldLoop(direction) {\n        if (direction === 1) return reachedMax(location.get());\n        if (direction === -1) return reachedMin(location.get());\n        return false;\n    }\n    function loop(direction) {\n        if (!shouldLoop(direction)) return;\n        const loopDistance = contentSize * (direction * -1);\n        vectors.forEach((v)=>v.add(loopDistance));\n    }\n    const self = {\n        loop\n    };\n    return self;\n}\nfunction ScrollProgress(limit) {\n    const { max, length } = limit;\n    function get(n) {\n        const currentLocation = n - max;\n        return length ? currentLocation / -length : 0;\n    }\n    const self = {\n        get\n    };\n    return self;\n}\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {\n    const { startEdge, endEdge } = axis;\n    const { groupSlides } = slidesToScroll;\n    const alignments = measureSizes().map(alignment.measure);\n    const snaps = measureUnaligned();\n    const snapsAligned = measureAligned();\n    function measureSizes() {\n        return groupSlides(slideRects).map((rects)=>arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);\n    }\n    function measureUnaligned() {\n        return slideRects.map((rect)=>containerRect[startEdge] - rect[startEdge]).map((snap)=>-mathAbs(snap));\n    }\n    function measureAligned() {\n        return groupSlides(snaps).map((g)=>g[0]).map((snap, index)=>snap + alignments[index]);\n    }\n    const self = {\n        snaps,\n        snapsAligned\n    };\n    return self;\n}\nfunction SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {\n    const { groupSlides } = slidesToScroll;\n    const { min, max } = scrollContainLimit;\n    const slideRegistry = createSlideRegistry();\n    function createSlideRegistry() {\n        const groupedSlideIndexes = groupSlides(slideIndexes);\n        const doNotContain = !containSnaps || containScroll === \"keepSnaps\";\n        if (scrollSnaps.length === 1) return [\n            slideIndexes\n        ];\n        if (doNotContain) return groupedSlideIndexes;\n        return groupedSlideIndexes.slice(min, max).map((group, index, groups)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(groups, index);\n            if (isFirst) {\n                const range = arrayLast(groups[0]) + 1;\n                return arrayFromNumber(range);\n            }\n            if (isLast) {\n                const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;\n                return arrayFromNumber(range, arrayLast(groups)[0]);\n            }\n            return group;\n        });\n    }\n    const self = {\n        slideRegistry\n    };\n    return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n    const { reachedAny, removeOffset, constrain } = limit;\n    function minDistance(distances) {\n        return distances.concat().sort((a, b)=>mathAbs(a) - mathAbs(b))[0];\n    }\n    function findTargetSnap(target) {\n        const distance = loop ? removeOffset(target) : constrain(target);\n        const ascDiffsToSnaps = scrollSnaps.map((snap, index)=>({\n                diff: shortcut(snap - distance, 0),\n                index\n            })).sort((d1, d2)=>mathAbs(d1.diff) - mathAbs(d2.diff));\n        const { index } = ascDiffsToSnaps[0];\n        return {\n            index,\n            distance\n        };\n    }\n    function shortcut(target, direction) {\n        const targets = [\n            target,\n            target + contentSize,\n            target - contentSize\n        ];\n        if (!loop) return target;\n        if (!direction) return minDistance(targets);\n        const matchingTargets = targets.filter((t)=>mathSign(t) === direction);\n        if (matchingTargets.length) return minDistance(matchingTargets);\n        return arrayLast(targets) - contentSize;\n    }\n    function byIndex(index, direction) {\n        const diffToSnap = scrollSnaps[index] - targetVector.get();\n        const distance = shortcut(diffToSnap, direction);\n        return {\n            index,\n            distance\n        };\n    }\n    function byDistance(distance, snap) {\n        const target = targetVector.get() + distance;\n        const { index, distance: targetSnapDistance } = findTargetSnap(target);\n        const reachedBound = !loop && reachedAny(target);\n        if (!snap || reachedBound) return {\n            index,\n            distance\n        };\n        const diffToSnap = scrollSnaps[index] - targetSnapDistance;\n        const snapDistance = distance + shortcut(diffToSnap, 0);\n        return {\n            index,\n            distance: snapDistance\n        };\n    }\n    const self = {\n        byDistance,\n        byIndex,\n        shortcut\n    };\n    return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {\n    function scrollTo(target) {\n        const distanceDiff = target.distance;\n        const indexDiff = target.index !== indexCurrent.get();\n        targetVector.add(distanceDiff);\n        if (distanceDiff) {\n            if (scrollBody.duration()) {\n                animation.start();\n            } else {\n                animation.update();\n                animation.render(1);\n                animation.update();\n            }\n        }\n        if (indexDiff) {\n            indexPrevious.set(indexCurrent.get());\n            indexCurrent.set(target.index);\n            eventHandler.emit(\"select\");\n        }\n    }\n    function distance(n, snap) {\n        const target = scrollTarget.byDistance(n, snap);\n        scrollTo(target);\n    }\n    function index(n, direction) {\n        const targetIndex = indexCurrent.clone().set(n);\n        const target = scrollTarget.byIndex(targetIndex.get(), direction);\n        scrollTo(target);\n    }\n    const self = {\n        distance,\n        index\n    };\n    return self;\n}\nfunction SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {\n    const focusListenerOptions = {\n        passive: true,\n        capture: true\n    };\n    let lastTabPressTime = 0;\n    function init(emblaApi) {\n        if (!watchFocus) return;\n        function defaultCallback(index) {\n            const nowTime = new Date().getTime();\n            const diffTime = nowTime - lastTabPressTime;\n            if (diffTime > 10) return;\n            eventHandler.emit(\"slideFocusStart\");\n            root.scrollLeft = 0;\n            const group = slideRegistry.findIndex((group)=>group.includes(index));\n            if (!isNumber(group)) return;\n            scrollBody.useDuration(0);\n            scrollTo.index(group, 0);\n            eventHandler.emit(\"slideFocus\");\n        }\n        eventStore.add(document, \"keydown\", registerTabPress, false);\n        slides.forEach((slide, slideIndex)=>{\n            eventStore.add(slide, \"focus\", (evt)=>{\n                if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {\n                    defaultCallback(slideIndex);\n                }\n            }, focusListenerOptions);\n        });\n    }\n    function registerTabPress(event) {\n        if (event.code === \"Tab\") lastTabPressTime = new Date().getTime();\n    }\n    const self = {\n        init\n    };\n    return self;\n}\nfunction Vector1D(initialValue) {\n    let value = initialValue;\n    function get() {\n        return value;\n    }\n    function set(n) {\n        value = normalizeInput(n);\n    }\n    function add(n) {\n        value += normalizeInput(n);\n    }\n    function subtract(n) {\n        value -= normalizeInput(n);\n    }\n    function normalizeInput(n) {\n        return isNumber(n) ? n : n.get();\n    }\n    const self = {\n        get,\n        set,\n        add,\n        subtract\n    };\n    return self;\n}\nfunction Translate(axis, container) {\n    const translate = axis.scroll === \"x\" ? x : y;\n    const containerStyle = container.style;\n    let disabled = false;\n    function x(n) {\n        return `translate3d(${n}px,0px,0px)`;\n    }\n    function y(n) {\n        return `translate3d(0px,${n}px,0px)`;\n    }\n    function to(target) {\n        if (disabled) return;\n        containerStyle.transform = translate(axis.direction(target));\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    function clear() {\n        if (disabled) return;\n        containerStyle.transform = \"\";\n        if (!container.getAttribute(\"style\")) container.removeAttribute(\"style\");\n    }\n    const self = {\n        clear,\n        to,\n        toggleActive\n    };\n    return self;\n}\nfunction SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {\n    const roundingSafety = 0.5;\n    const ascItems = arrayKeys(slideSizesWithGaps);\n    const descItems = arrayKeys(slideSizesWithGaps).reverse();\n    const loopPoints = startPoints().concat(endPoints());\n    function removeSlideSizes(indexes, from) {\n        return indexes.reduce((a, i)=>{\n            return a - slideSizesWithGaps[i];\n        }, from);\n    }\n    function slidesInGap(indexes, gap) {\n        return indexes.reduce((a, i)=>{\n            const remainingGap = removeSlideSizes(a, gap);\n            return remainingGap > 0 ? a.concat([\n                i\n            ]) : a;\n        }, []);\n    }\n    function findSlideBounds(offset) {\n        return snaps.map((snap, index)=>({\n                start: snap - slideSizes[index] + roundingSafety + offset,\n                end: snap + viewSize - roundingSafety + offset\n            }));\n    }\n    function findLoopPoints(indexes, offset, isEndEdge) {\n        const slideBounds = findSlideBounds(offset);\n        return indexes.map((index)=>{\n            const initial = isEndEdge ? 0 : -contentSize;\n            const altered = isEndEdge ? contentSize : 0;\n            const boundEdge = isEndEdge ? \"end\" : \"start\";\n            const loopPoint = slideBounds[index][boundEdge];\n            return {\n                index,\n                loopPoint,\n                slideLocation: Vector1D(-1),\n                translate: Translate(axis, slides[index]),\n                target: ()=>location.get() > loopPoint ? initial : altered\n            };\n        });\n    }\n    function startPoints() {\n        const gap = scrollSnaps[0];\n        const indexes = slidesInGap(descItems, gap);\n        return findLoopPoints(indexes, contentSize, false);\n    }\n    function endPoints() {\n        const gap = viewSize - scrollSnaps[0] - 1;\n        const indexes = slidesInGap(ascItems, gap);\n        return findLoopPoints(indexes, -contentSize, true);\n    }\n    function canLoop() {\n        return loopPoints.every(({ index })=>{\n            const otherIndexes = ascItems.filter((i)=>i !== index);\n            return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n        });\n    }\n    function loop() {\n        loopPoints.forEach((loopPoint)=>{\n            const { target, translate, slideLocation } = loopPoint;\n            const shiftLocation = target();\n            if (shiftLocation === slideLocation.get()) return;\n            translate.to(shiftLocation);\n            slideLocation.set(shiftLocation);\n        });\n    }\n    function clear() {\n        loopPoints.forEach((loopPoint)=>loopPoint.translate.clear());\n    }\n    const self = {\n        canLoop,\n        clear,\n        loop,\n        loopPoints\n    };\n    return self;\n}\nfunction SlidesHandler(container, eventHandler, watchSlides) {\n    let mutationObserver;\n    let destroyed = false;\n    function init(emblaApi) {\n        if (!watchSlides) return;\n        function defaultCallback(mutations) {\n            for (const mutation of mutations){\n                if (mutation.type === \"childList\") {\n                    emblaApi.reInit();\n                    eventHandler.emit(\"slidesChanged\");\n                    break;\n                }\n            }\n        }\n        mutationObserver = new MutationObserver((mutations)=>{\n            if (destroyed) return;\n            if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n                defaultCallback(mutations);\n            }\n        });\n        mutationObserver.observe(container, {\n            childList: true\n        });\n    }\n    function destroy() {\n        if (mutationObserver) mutationObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction SlidesInView(container, slides, eventHandler, threshold) {\n    const intersectionEntryMap = {};\n    let inViewCache = null;\n    let notInViewCache = null;\n    let intersectionObserver;\n    let destroyed = false;\n    function init() {\n        intersectionObserver = new IntersectionObserver((entries)=>{\n            if (destroyed) return;\n            entries.forEach((entry)=>{\n                const index = slides.indexOf(entry.target);\n                intersectionEntryMap[index] = entry;\n            });\n            inViewCache = null;\n            notInViewCache = null;\n            eventHandler.emit(\"slidesInView\");\n        }, {\n            root: container.parentElement,\n            threshold\n        });\n        slides.forEach((slide)=>intersectionObserver.observe(slide));\n    }\n    function destroy() {\n        if (intersectionObserver) intersectionObserver.disconnect();\n        destroyed = true;\n    }\n    function createInViewList(inView) {\n        return objectKeys(intersectionEntryMap).reduce((list, slideIndex)=>{\n            const index = parseInt(slideIndex);\n            const { isIntersecting } = intersectionEntryMap[index];\n            const inViewMatch = inView && isIntersecting;\n            const notInViewMatch = !inView && !isIntersecting;\n            if (inViewMatch || notInViewMatch) list.push(index);\n            return list;\n        }, []);\n    }\n    function get(inView = true) {\n        if (inView && inViewCache) return inViewCache;\n        if (!inView && notInViewCache) return notInViewCache;\n        const slideIndexes = createInViewList(inView);\n        if (inView) inViewCache = slideIndexes;\n        if (!inView) notInViewCache = slideIndexes;\n        return slideIndexes;\n    }\n    const self = {\n        init,\n        destroy,\n        get\n    };\n    return self;\n}\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n    const { measureSize, startEdge, endEdge } = axis;\n    const withEdgeGap = slideRects[0] && readEdgeGap;\n    const startGap = measureStartGap();\n    const endGap = measureEndGap();\n    const slideSizes = slideRects.map(measureSize);\n    const slideSizesWithGaps = measureWithGaps();\n    function measureStartGap() {\n        if (!withEdgeGap) return 0;\n        const slideRect = slideRects[0];\n        return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n    }\n    function measureEndGap() {\n        if (!withEdgeGap) return 0;\n        const style = ownerWindow.getComputedStyle(arrayLast(slides));\n        return parseFloat(style.getPropertyValue(`margin-${endEdge}`));\n    }\n    function measureWithGaps() {\n        return slideRects.map((rect, index, rects)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(rects, index);\n            if (isFirst) return slideSizes[index] + startGap;\n            if (isLast) return slideSizes[index] + endGap;\n            return rects[index + 1][startEdge] - rect[startEdge];\n        }).map(mathAbs);\n    }\n    const self = {\n        slideSizes,\n        slideSizesWithGaps,\n        startGap,\n        endGap\n    };\n    return self;\n}\nfunction SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {\n    const { startEdge, endEdge, direction } = axis;\n    const groupByNumber = isNumber(slidesToScroll);\n    function byNumber(array, groupSize) {\n        return arrayKeys(array).filter((i)=>i % groupSize === 0).map((i)=>array.slice(i, i + groupSize));\n    }\n    function bySize(array) {\n        if (!array.length) return [];\n        return arrayKeys(array).reduce((groups, rectB, index)=>{\n            const rectA = arrayLast(groups) || 0;\n            const isFirst = rectA === 0;\n            const isLast = rectB === arrayLastIndex(array);\n            const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];\n            const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];\n            const gapA = !loop && isFirst ? direction(startGap) : 0;\n            const gapB = !loop && isLast ? direction(endGap) : 0;\n            const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));\n            if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB);\n            if (isLast) groups.push(array.length);\n            return groups;\n        }, []).map((currentSize, index, groups)=>{\n            const previousSize = Math.max(groups[index - 1] || 0);\n            return array.slice(previousSize, currentSize);\n        });\n    }\n    function groupSlides(array) {\n        return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n    }\n    const self = {\n        groupSlides\n    };\n    return self;\n}\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {\n    // Options\n    const { align, axis: scrollAxis, direction, startIndex, loop, duration, dragFree, dragThreshold, inViewThreshold, slidesToScroll: groupSlides, skipSnaps, containScroll, watchResize, watchSlides, watchDrag, watchFocus } = options;\n    // Measurements\n    const pixelTolerance = 2;\n    const nodeRects = NodeRects();\n    const containerRect = nodeRects.measure(container);\n    const slideRects = slides.map(nodeRects.measure);\n    const axis = Axis(scrollAxis, direction);\n    const viewSize = axis.measureSize(containerRect);\n    const percentOfView = PercentOfView(viewSize);\n    const alignment = Alignment(align, viewSize);\n    const containSnaps = !loop && !!containScroll;\n    const readEdgeGap = loop || !!containScroll;\n    const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);\n    const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);\n    const { snaps, snapsAligned } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);\n    const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n    const { snapsContained, scrollContainLimit } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);\n    const scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n    const { limit } = ScrollLimit(contentSize, scrollSnaps, loop);\n    // Indexes\n    const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n    const indexPrevious = index.clone();\n    const slideIndexes = arrayKeys(slides);\n    // Animation\n    const update = ({ dragHandler, scrollBody, scrollBounds, options: { loop } }, timeStep)=>{\n        if (!loop) scrollBounds.constrain(dragHandler.pointerDown());\n        scrollBody.seek(timeStep);\n    };\n    const render = ({ scrollBody, translate, location, offsetLocation, scrollLooper, slideLooper, dragHandler, animation, eventHandler, scrollBounds, options: { loop } }, lagOffset)=>{\n        const shouldSettle = scrollBody.settled();\n        const withinBounds = !scrollBounds.shouldConstrain();\n        const hasSettled = loop ? shouldSettle : shouldSettle && withinBounds;\n        if (hasSettled && !dragHandler.pointerDown()) {\n            animation.stop();\n            eventHandler.emit(\"settle\");\n        }\n        if (!hasSettled) eventHandler.emit(\"scroll\");\n        const interpolatedLocation = location.get() * lagOffset + previousLocation.get() * (1 - lagOffset);\n        offsetLocation.set(interpolatedLocation);\n        if (loop) {\n            scrollLooper.loop(scrollBody.direction());\n            slideLooper.loop();\n        }\n        translate.to(offsetLocation.get());\n    };\n    const animation = Animations(ownerDocument, ownerWindow, (timeStep)=>update(engine, timeStep), (lagOffset)=>render(engine, lagOffset));\n    // Shared\n    const friction = 0.68;\n    const startLocation = scrollSnaps[index.get()];\n    const location = Vector1D(startLocation);\n    const previousLocation = Vector1D(startLocation);\n    const offsetLocation = Vector1D(startLocation);\n    const target = Vector1D(startLocation);\n    const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);\n    const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n    const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);\n    const scrollProgress = ScrollProgress(limit);\n    const eventStore = EventStore();\n    const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);\n    const { slideRegistry } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);\n    const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);\n    // Engine\n    const engine = {\n        ownerDocument,\n        ownerWindow,\n        eventHandler,\n        containerRect,\n        slideRects,\n        animation,\n        axis,\n        dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),\n        eventStore,\n        percentOfView,\n        index,\n        indexPrevious,\n        limit,\n        location,\n        offsetLocation,\n        previousLocation,\n        options,\n        resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),\n        scrollBody,\n        scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),\n        scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n            location,\n            offsetLocation,\n            previousLocation,\n            target\n        ]),\n        scrollProgress,\n        scrollSnapList: scrollSnaps.map(scrollProgress.get),\n        scrollSnaps,\n        scrollTarget,\n        scrollTo,\n        slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),\n        slideFocus,\n        slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n        slidesInView,\n        slideIndexes,\n        slideRegistry,\n        slidesToScroll,\n        target,\n        translate: Translate(axis, container)\n    };\n    return engine;\n}\nfunction EventHandler() {\n    let listeners = {};\n    let api;\n    function init(emblaApi) {\n        api = emblaApi;\n    }\n    function getListeners(evt) {\n        return listeners[evt] || [];\n    }\n    function emit(evt) {\n        getListeners(evt).forEach((e)=>e(api, evt));\n        return self;\n    }\n    function on(evt, cb) {\n        listeners[evt] = getListeners(evt).concat([\n            cb\n        ]);\n        return self;\n    }\n    function off(evt, cb) {\n        listeners[evt] = getListeners(evt).filter((e)=>e !== cb);\n        return self;\n    }\n    function clear() {\n        listeners = {};\n    }\n    const self = {\n        init,\n        emit,\n        off,\n        on,\n        clear\n    };\n    return self;\n}\nconst defaultOptions = {\n    align: \"center\",\n    axis: \"x\",\n    container: null,\n    slides: null,\n    containScroll: \"trimSnaps\",\n    direction: \"ltr\",\n    slidesToScroll: 1,\n    inViewThreshold: 0,\n    breakpoints: {},\n    dragFree: false,\n    dragThreshold: 10,\n    loop: false,\n    skipSnaps: false,\n    duration: 25,\n    startIndex: 0,\n    active: true,\n    watchDrag: true,\n    watchResize: true,\n    watchSlides: true,\n    watchFocus: true\n};\nfunction OptionsHandler(ownerWindow) {\n    function mergeOptions(optionsA, optionsB) {\n        return objectsMergeDeep(optionsA, optionsB || {});\n    }\n    function optionsAtMedia(options) {\n        const optionsAtMedia = options.breakpoints || {};\n        const matchedMediaOptions = objectKeys(optionsAtMedia).filter((media)=>ownerWindow.matchMedia(media).matches).map((media)=>optionsAtMedia[media]).reduce((a, mediaOption)=>mergeOptions(a, mediaOption), {});\n        return mergeOptions(options, matchedMediaOptions);\n    }\n    function optionsMediaQueries(optionsList) {\n        return optionsList.map((options)=>objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries)=>acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);\n    }\n    const self = {\n        mergeOptions,\n        optionsAtMedia,\n        optionsMediaQueries\n    };\n    return self;\n}\nfunction PluginsHandler(optionsHandler) {\n    let activePlugins = [];\n    function init(emblaApi, plugins) {\n        activePlugins = plugins.filter(({ options })=>optionsHandler.optionsAtMedia(options).active !== false);\n        activePlugins.forEach((plugin)=>plugin.init(emblaApi, optionsHandler));\n        return plugins.reduce((map, plugin)=>Object.assign(map, {\n                [plugin.name]: plugin\n            }), {});\n    }\n    function destroy() {\n        activePlugins = activePlugins.filter((plugin)=>plugin.destroy());\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n    const ownerDocument = root.ownerDocument;\n    const ownerWindow = ownerDocument.defaultView;\n    const optionsHandler = OptionsHandler(ownerWindow);\n    const pluginsHandler = PluginsHandler(optionsHandler);\n    const mediaHandlers = EventStore();\n    const eventHandler = EventHandler();\n    const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler;\n    const { on, off, emit } = eventHandler;\n    const reInit = reActivate;\n    let destroyed = false;\n    let engine;\n    let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n    let options = mergeOptions(optionsBase);\n    let pluginList = [];\n    let pluginApis;\n    let container;\n    let slides;\n    function storeElements() {\n        const { container: userContainer, slides: userSlides } = options;\n        const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n        container = customContainer || root.children[0];\n        const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n        slides = [].slice.call(customSlides || container.children);\n    }\n    function createEngine(options) {\n        const engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler);\n        if (options.loop && !engine.slideLooper.canLoop()) {\n            const optionsWithoutLoop = Object.assign({}, options, {\n                loop: false\n            });\n            return createEngine(optionsWithoutLoop);\n        }\n        return engine;\n    }\n    function activate(withOptions, withPlugins) {\n        if (destroyed) return;\n        optionsBase = mergeOptions(optionsBase, withOptions);\n        options = optionsAtMedia(optionsBase);\n        pluginList = withPlugins || pluginList;\n        storeElements();\n        engine = createEngine(options);\n        optionsMediaQueries([\n            optionsBase,\n            ...pluginList.map(({ options })=>options)\n        ]).forEach((query)=>mediaHandlers.add(query, \"change\", reActivate));\n        if (!options.active) return;\n        engine.translate.to(engine.location.get());\n        engine.animation.init();\n        engine.slidesInView.init();\n        engine.slideFocus.init(self);\n        engine.eventHandler.init(self);\n        engine.resizeHandler.init(self);\n        engine.slidesHandler.init(self);\n        if (engine.options.loop) engine.slideLooper.loop();\n        if (container.offsetParent && slides.length) engine.dragHandler.init(self);\n        pluginApis = pluginsHandler.init(self, pluginList);\n    }\n    function reActivate(withOptions, withPlugins) {\n        const startIndex = selectedScrollSnap();\n        deActivate();\n        activate(mergeOptions({\n            startIndex\n        }, withOptions), withPlugins);\n        eventHandler.emit(\"reInit\");\n    }\n    function deActivate() {\n        engine.dragHandler.destroy();\n        engine.eventStore.clear();\n        engine.translate.clear();\n        engine.slideLooper.clear();\n        engine.resizeHandler.destroy();\n        engine.slidesHandler.destroy();\n        engine.slidesInView.destroy();\n        engine.animation.destroy();\n        pluginsHandler.destroy();\n        mediaHandlers.clear();\n    }\n    function destroy() {\n        if (destroyed) return;\n        destroyed = true;\n        mediaHandlers.clear();\n        deActivate();\n        eventHandler.emit(\"destroy\");\n        eventHandler.clear();\n    }\n    function scrollTo(index, jump, direction) {\n        if (!options.active || destroyed) return;\n        engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);\n        engine.scrollTo.index(index, direction || 0);\n    }\n    function scrollNext(jump) {\n        const next = engine.index.add(1).get();\n        scrollTo(next, jump, -1);\n    }\n    function scrollPrev(jump) {\n        const prev = engine.index.add(-1).get();\n        scrollTo(prev, jump, 1);\n    }\n    function canScrollNext() {\n        const next = engine.index.add(1).get();\n        return next !== selectedScrollSnap();\n    }\n    function canScrollPrev() {\n        const prev = engine.index.add(-1).get();\n        return prev !== selectedScrollSnap();\n    }\n    function scrollSnapList() {\n        return engine.scrollSnapList;\n    }\n    function scrollProgress() {\n        return engine.scrollProgress.get(engine.location.get());\n    }\n    function selectedScrollSnap() {\n        return engine.index.get();\n    }\n    function previousScrollSnap() {\n        return engine.indexPrevious.get();\n    }\n    function slidesInView() {\n        return engine.slidesInView.get();\n    }\n    function slidesNotInView() {\n        return engine.slidesInView.get(false);\n    }\n    function plugins() {\n        return pluginApis;\n    }\n    function internalEngine() {\n        return engine;\n    }\n    function rootNode() {\n        return root;\n    }\n    function containerNode() {\n        return container;\n    }\n    function slideNodes() {\n        return slides;\n    }\n    const self = {\n        canScrollNext,\n        canScrollPrev,\n        containerNode,\n        internalEngine,\n        destroy,\n        off,\n        on,\n        emit,\n        plugins,\n        previousScrollSnap,\n        reInit,\n        rootNode,\n        scrollNext,\n        scrollPrev,\n        scrollProgress,\n        scrollSnapList,\n        scrollTo,\n        selectedScrollSnap,\n        slideNodes,\n        slidesInView,\n        slidesNotInView\n    };\n    activate(userOptions, userPlugins);\n    setTimeout(()=>eventHandler.emit(\"init\"), 0);\n    return self;\n}\nEmblaCarousel.globalOptions = undefined;\n //# sourceMappingURL=embla-carousel.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwvZXNtL2VtYmxhLWNhcm91c2VsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsU0FBU0MsT0FBTztJQUN2QixPQUFPLE9BQU9BLFlBQVk7QUFDNUI7QUFDQSxTQUFTQyxTQUFTRCxPQUFPO0lBQ3ZCLE9BQU8sT0FBT0EsWUFBWTtBQUM1QjtBQUNBLFNBQVNFLFVBQVVGLE9BQU87SUFDeEIsT0FBTyxPQUFPQSxZQUFZO0FBQzVCO0FBQ0EsU0FBU0csU0FBU0gsT0FBTztJQUN2QixPQUFPSSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUCxhQUFhO0FBQ3JEO0FBQ0EsU0FBU1EsUUFBUUMsQ0FBQztJQUNoQixPQUFPQyxLQUFLQyxHQUFHLENBQUNGO0FBQ2xCO0FBQ0EsU0FBU0csU0FBU0gsQ0FBQztJQUNqQixPQUFPQyxLQUFLRyxJQUFJLENBQUNKO0FBQ25CO0FBQ0EsU0FBU0ssU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQzlCLE9BQU9SLFFBQVFPLFNBQVNDO0FBQzFCO0FBQ0EsU0FBU0MsVUFBVUYsTUFBTSxFQUFFQyxNQUFNO0lBQy9CLElBQUlELFdBQVcsS0FBS0MsV0FBVyxHQUFHLE9BQU87SUFDekMsSUFBSVIsUUFBUU8sV0FBV1AsUUFBUVEsU0FBUyxPQUFPO0lBQy9DLE1BQU1FLE9BQU9KLFNBQVNOLFFBQVFPLFNBQVNQLFFBQVFRO0lBQy9DLE9BQU9SLFFBQVFVLE9BQU9IO0FBQ3hCO0FBQ0EsU0FBU0ksVUFBVUMsS0FBSztJQUN0QixPQUFPQyxXQUFXRCxPQUFPRSxHQUFHLENBQUNDO0FBQy9CO0FBQ0EsU0FBU0MsVUFBVUosS0FBSztJQUN0QixPQUFPQSxLQUFLLENBQUNLLGVBQWVMLE9BQU87QUFDckM7QUFDQSxTQUFTSyxlQUFlTCxLQUFLO0lBQzNCLE9BQU9WLEtBQUtnQixHQUFHLENBQUMsR0FBR04sTUFBTU8sTUFBTSxHQUFHO0FBQ3BDO0FB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O1FBQ0E0WjtRQUNBRjtRQUNBblQ7UUFDQXlVO1FBQ0FzQztRQUNBblQ7UUFDQTFIO1FBQ0F3YTtRQUNBQztRQUNBbEU7UUFDQUk7UUFDQXRXO1FBQ0FnYTtRQUNBWTtRQUNBekU7UUFDQXNFO0lBQ0Y7SUFDQWQsU0FBU3BCLGFBQWFDO0lBQ3RCcUMsV0FBVyxJQUFNMWEsYUFBYXNELElBQUksQ0FBQyxTQUFTO0lBQzVDLE9BQU9ySTtBQUNUO0FBQ0FrZCxjQUFjUSxhQUFhLEdBQUc5VztBQUVNLENBQ3BDLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyZWxsby1jbG9uZS8uL25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC9lc20vZW1ibGEtY2Fyb3VzZWwuZXNtLmpzPzJkODAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaXNOdW1iZXIoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdudW1iZXInO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdzdHJpbmcnO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuZnVuY3Rpb24gbWF0aEFicyhuKSB7XG4gIHJldHVybiBNYXRoLmFicyhuKTtcbn1cbmZ1bmN0aW9uIG1hdGhTaWduKG4pIHtcbiAgcmV0dXJuIE1hdGguc2lnbihuKTtcbn1cbmZ1bmN0aW9uIGRlbHRhQWJzKHZhbHVlQiwgdmFsdWVBKSB7XG4gIHJldHVybiBtYXRoQWJzKHZhbHVlQiAtIHZhbHVlQSk7XG59XG5mdW5jdGlvbiBmYWN0b3JBYnModmFsdWVCLCB2YWx1ZUEpIHtcbiAgaWYgKHZhbHVlQiA9PT0gMCB8fCB2YWx1ZUEgPT09IDApIHJldHVybiAwO1xuICBpZiAobWF0aEFicyh2YWx1ZUIpIDw9IG1hdGhBYnModmFsdWVBKSkgcmV0dXJuIDA7XG4gIGNvbnN0IGRpZmYgPSBkZWx0YUFicyhtYXRoQWJzKHZhbHVlQiksIG1hdGhBYnModmFsdWVBKSk7XG4gIHJldHVybiBtYXRoQWJzKGRpZmYgLyB2YWx1ZUIpO1xufVxuZnVuY3Rpb24gYXJyYXlLZXlzKGFycmF5KSB7XG4gIHJldHVybiBvYmplY3RLZXlzKGFycmF5KS5tYXAoTnVtYmVyKTtcbn1cbmZ1bmN0aW9uIGFycmF5TGFzdChhcnJheSkge1xuICByZXR1cm4gYXJyYXlbYXJyYXlMYXN0SW5kZXgoYXJyYXkpXTtcbn1cbmZ1bmN0aW9uIGFycmF5TGFzdEluZGV4KGFycmF5KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIGFycmF5SXNMYXN0SW5kZXgoYXJyYXksIGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA9PT0gYXJyYXlMYXN0SW5kZXgoYXJyYXkpO1xufVxuZnVuY3Rpb24gYXJyYXlGcm9tTnVtYmVyKG4sIHN0YXJ0QXQgPSAwKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKEFycmF5KG4pLCAoXywgaSkgPT4gc3RhcnRBdCArIGkpO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG59XG5mdW5jdGlvbiBvYmplY3RzTWVyZ2VEZWVwKG9iamVjdEEsIG9iamVjdEIpIHtcbiAgcmV0dXJuIFtvYmplY3RBLCBvYmplY3RCXS5yZWR1Y2UoKG1lcmdlZE9iamVjdHMsIGN1cnJlbnRPYmplY3QpID0+IHtcbiAgICBvYmplY3RLZXlzKGN1cnJlbnRPYmplY3QpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlQSA9IG1lcmdlZE9iamVjdHNba2V5XTtcbiAgICAgIGNvbnN0IHZhbHVlQiA9IGN1cnJlbnRPYmplY3Rba2V5XTtcbiAgICAgIGNvbnN0IGFyZU9iamVjdHMgPSBpc09iamVjdCh2YWx1ZUEpICYmIGlzT2JqZWN0KHZhbHVlQik7XG4gICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBhcmVPYmplY3RzID8gb2JqZWN0c01lcmdlRGVlcCh2YWx1ZUEsIHZhbHVlQikgOiB2YWx1ZUI7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZE9iamVjdHM7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KSB7XG4gIHJldHVybiB0eXBlb2Ygb3duZXJXaW5kb3cuTW91c2VFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZ0IGluc3RhbmNlb2Ygb3duZXJXaW5kb3cuTW91c2VFdmVudDtcbn1cblxuZnVuY3Rpb24gQWxpZ25tZW50KGFsaWduLCB2aWV3U2l6ZSkge1xuICBjb25zdCBwcmVkZWZpbmVkID0ge1xuICAgIHN0YXJ0LFxuICAgIGNlbnRlcixcbiAgICBlbmRcbiAgfTtcbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZnVuY3Rpb24gY2VudGVyKG4pIHtcbiAgICByZXR1cm4gZW5kKG4pIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBlbmQobikge1xuICAgIHJldHVybiB2aWV3U2l6ZSAtIG47XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZShuLCBpbmRleCkge1xuICAgIGlmIChpc1N0cmluZyhhbGlnbikpIHJldHVybiBwcmVkZWZpbmVkW2FsaWduXShuKTtcbiAgICByZXR1cm4gYWxpZ24odmlld1NpemUsIG4sIGluZGV4KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG1lYXN1cmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U3RvcmUoKSB7XG4gIGxldCBsaXN0ZW5lcnMgPSBbXTtcbiAgZnVuY3Rpb24gYWRkKG5vZGUsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KSB7XG4gICAgbGV0IHJlbW92ZUxpc3RlbmVyO1xuICAgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gbm9kZSkge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlZ2FjeU1lZGlhUXVlcnlMaXN0ID0gbm9kZTtcbiAgICAgIGxlZ2FjeU1lZGlhUXVlcnlMaXN0LmFkZExpc3RlbmVyKGhhbmRsZXIpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiBsZWdhY3lNZWRpYVF1ZXJ5TGlzdC5yZW1vdmVMaXN0ZW5lcihoYW5kbGVyKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLnB1c2gocmVtb3ZlTGlzdGVuZXIpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIocmVtb3ZlID0+IHJlbW92ZSgpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGFkZCxcbiAgICBjbGVhclxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9ucyhvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgdXBkYXRlLCByZW5kZXIpIHtcbiAgY29uc3QgZG9jdW1lbnRWaXNpYmxlSGFuZGxlciA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgdGltZVN0ZXAgPSAxMDAwIC8gNjA7XG4gIGxldCBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgbGV0IGxhZyA9IDA7XG4gIGxldCBhbmltYXRpb25GcmFtZSA9IDA7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5hZGQob3duZXJEb2N1bWVudCwgJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBpZiAob3duZXJEb2N1bWVudC5oaWRkZW4pIHJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBzdG9wKCk7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGFuaW1hdGUodGltZVN0YW1wKSB7XG4gICAgaWYgKCFhbmltYXRpb25GcmFtZSkgcmV0dXJuO1xuICAgIGlmICghbGFzdFRpbWVTdGFtcCkgbGFzdFRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICBjb25zdCBlbGFwc2VkID0gdGltZVN0YW1wIC0gbGFzdFRpbWVTdGFtcDtcbiAgICBsYXN0VGltZVN0YW1wID0gdGltZVN0YW1wO1xuICAgIGxhZyArPSBlbGFwc2VkO1xuICAgIHdoaWxlIChsYWcgPj0gdGltZVN0ZXApIHtcbiAgICAgIHVwZGF0ZSh0aW1lU3RlcCk7XG4gICAgICBsYWcgLT0gdGltZVN0ZXA7XG4gICAgfVxuICAgIGNvbnN0IGxhZ09mZnNldCA9IGxhZyAvIHRpbWVTdGVwO1xuICAgIHJlbmRlcihsYWdPZmZzZXQpO1xuICAgIGlmIChhbmltYXRpb25GcmFtZSkgb3duZXJXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGlmIChhbmltYXRpb25GcmFtZSkgcmV0dXJuO1xuICAgIGFuaW1hdGlvbkZyYW1lID0gb3duZXJXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgb3duZXJXaW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWUpO1xuICAgIGxhc3RUaW1lU3RhbXAgPSBudWxsO1xuICAgIGxhZyA9IDA7XG4gICAgYW5pbWF0aW9uRnJhbWUgPSAwO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGxhc3RUaW1lU3RhbXAgPSBudWxsO1xuICAgIGxhZyA9IDA7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICB1cGRhdGU6ICgpID0+IHVwZGF0ZSh0aW1lU3RlcCksXG4gICAgcmVuZGVyXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBBeGlzKGF4aXMsIGNvbnRlbnREaXJlY3Rpb24pIHtcbiAgY29uc3QgaXNSaWdodFRvTGVmdCA9IGNvbnRlbnREaXJlY3Rpb24gPT09ICdydGwnO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gYXhpcyA9PT0gJ3knO1xuICBjb25zdCBzY3JvbGwgPSBpc1ZlcnRpY2FsID8gJ3knIDogJ3gnO1xuICBjb25zdCBjcm9zcyA9IGlzVmVydGljYWwgPyAneCcgOiAneSc7XG4gIGNvbnN0IHNpZ24gPSAhaXNWZXJ0aWNhbCAmJiBpc1JpZ2h0VG9MZWZ0ID8gLTEgOiAxO1xuICBjb25zdCBzdGFydEVkZ2UgPSBnZXRTdGFydEVkZ2UoKTtcbiAgY29uc3QgZW5kRWRnZSA9IGdldEVuZEVkZ2UoKTtcbiAgZnVuY3Rpb24gbWVhc3VyZVNpemUobm9kZVJlY3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBub2RlUmVjdDtcbiAgICByZXR1cm4gaXNWZXJ0aWNhbCA/IGhlaWdodCA6IHdpZHRoO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXJ0RWRnZSgpIHtcbiAgICBpZiAoaXNWZXJ0aWNhbCkgcmV0dXJuICd0b3AnO1xuICAgIHJldHVybiBpc1JpZ2h0VG9MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgfVxuICBmdW5jdGlvbiBnZXRFbmRFZGdlKCkge1xuICAgIGlmIChpc1ZlcnRpY2FsKSByZXR1cm4gJ2JvdHRvbSc7XG4gICAgcmV0dXJuIGlzUmlnaHRUb0xlZnQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9XG4gIGZ1bmN0aW9uIGRpcmVjdGlvbihuKSB7XG4gICAgcmV0dXJuIG4gKiBzaWduO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc2Nyb2xsLFxuICAgIGNyb3NzLFxuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlLFxuICAgIG1lYXN1cmVTaXplLFxuICAgIGRpcmVjdGlvblxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gTGltaXQobWluID0gMCwgbWF4ID0gMCkge1xuICBjb25zdCBsZW5ndGggPSBtYXRoQWJzKG1pbiAtIG1heCk7XG4gIGZ1bmN0aW9uIHJlYWNoZWRNaW4obikge1xuICAgIHJldHVybiBuIDwgbWluO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWNoZWRNYXgobikge1xuICAgIHJldHVybiBuID4gbWF4O1xuICB9XG4gIGZ1bmN0aW9uIHJlYWNoZWRBbnkobikge1xuICAgIHJldHVybiByZWFjaGVkTWluKG4pIHx8IHJlYWNoZWRNYXgobik7XG4gIH1cbiAgZnVuY3Rpb24gY29uc3RyYWluKG4pIHtcbiAgICBpZiAoIXJlYWNoZWRBbnkobikpIHJldHVybiBuO1xuICAgIHJldHVybiByZWFjaGVkTWluKG4pID8gbWluIDogbWF4O1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9mZnNldChuKSB7XG4gICAgaWYgKCFsZW5ndGgpIHJldHVybiBuO1xuICAgIHJldHVybiBuIC0gbGVuZ3RoICogTWF0aC5jZWlsKChuIC0gbWF4KSAvIGxlbmd0aCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBsZW5ndGgsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBjb25zdHJhaW4sXG4gICAgcmVhY2hlZEFueSxcbiAgICByZWFjaGVkTWF4LFxuICAgIHJlYWNoZWRNaW4sXG4gICAgcmVtb3ZlT2Zmc2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBDb3VudGVyKG1heCwgc3RhcnQsIGxvb3ApIHtcbiAgY29uc3Qge1xuICAgIGNvbnN0cmFpblxuICB9ID0gTGltaXQoMCwgbWF4KTtcbiAgY29uc3QgbG9vcEVuZCA9IG1heCArIDE7XG4gIGxldCBjb3VudGVyID0gd2l0aGluTGltaXQoc3RhcnQpO1xuICBmdW5jdGlvbiB3aXRoaW5MaW1pdChuKSB7XG4gICAgcmV0dXJuICFsb29wID8gY29uc3RyYWluKG4pIDogbWF0aEFicygobG9vcEVuZCArIG4pICUgbG9vcEVuZCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9XG4gIGZ1bmN0aW9uIHNldChuKSB7XG4gICAgY291bnRlciA9IHdpdGhpbkxpbWl0KG4pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChuKSB7XG4gICAgcmV0dXJuIGNsb25lKCkuc2V0KGdldCgpICsgbik7XG4gIH1cbiAgZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIENvdW50ZXIobWF4LCBnZXQoKSwgbG9vcCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGFkZCxcbiAgICBjbG9uZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRHJhZ0hhbmRsZXIoYXhpcywgcm9vdE5vZGUsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCB0YXJnZXQsIGRyYWdUcmFja2VyLCBsb2NhdGlvbiwgYW5pbWF0aW9uLCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCBpbmRleCwgZXZlbnRIYW5kbGVyLCBwZXJjZW50T2ZWaWV3LCBkcmFnRnJlZSwgZHJhZ1RocmVzaG9sZCwgc2tpcFNuYXBzLCBiYXNlRnJpY3Rpb24sIHdhdGNoRHJhZykge1xuICBjb25zdCB7XG4gICAgY3Jvc3M6IGNyb3NzQXhpcyxcbiAgICBkaXJlY3Rpb25cbiAgfSA9IGF4aXM7XG4gIGNvbnN0IGZvY3VzTm9kZXMgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuICBjb25zdCBub25QYXNzaXZlRXZlbnQgPSB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfTtcbiAgY29uc3QgaW5pdEV2ZW50cyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZHJhZ0V2ZW50cyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZ29Ub05leHRUaHJlc2hvbGQgPSBMaW1pdCg1MCwgMjI1KS5jb25zdHJhaW4ocGVyY2VudE9mVmlldy5tZWFzdXJlKDIwKSk7XG4gIGNvbnN0IHNuYXBGb3JjZUJvb3N0ID0ge1xuICAgIG1vdXNlOiAzMDAsXG4gICAgdG91Y2g6IDQwMFxuICB9O1xuICBjb25zdCBmcmVlRm9yY2VCb29zdCA9IHtcbiAgICBtb3VzZTogNTAwLFxuICAgIHRvdWNoOiA2MDBcbiAgfTtcbiAgY29uc3QgYmFzZVNwZWVkID0gZHJhZ0ZyZWUgPyA0MyA6IDI1O1xuICBsZXQgaXNNb3ZpbmcgPSBmYWxzZTtcbiAgbGV0IHN0YXJ0U2Nyb2xsID0gMDtcbiAgbGV0IHN0YXJ0Q3Jvc3MgPSAwO1xuICBsZXQgcG9pbnRlcklzRG93biA9IGZhbHNlO1xuICBsZXQgcHJldmVudFNjcm9sbCA9IGZhbHNlO1xuICBsZXQgcHJldmVudENsaWNrID0gZmFsc2U7XG4gIGxldCBpc01vdXNlID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGkpIHtcbiAgICBpZiAoIXdhdGNoRHJhZykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGRvd25JZkFsbG93ZWQoZXZ0KSB7XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoRHJhZykgfHwgd2F0Y2hEcmFnKGVtYmxhQXBpLCBldnQpKSBkb3duKGV2dCk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSByb290Tm9kZTtcbiAgICBpbml0RXZlbnRzLmFkZChub2RlLCAnZHJhZ3N0YXJ0JywgZXZ0ID0+IGV2dC5wcmV2ZW50RGVmYXVsdCgpLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2htb3ZlJywgKCkgPT4gdW5kZWZpbmVkLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2hlbmQnLCAoKSA9PiB1bmRlZmluZWQpLmFkZChub2RlLCAndG91Y2hzdGFydCcsIGRvd25JZkFsbG93ZWQpLmFkZChub2RlLCAnbW91c2Vkb3duJywgZG93bklmQWxsb3dlZCkuYWRkKG5vZGUsICd0b3VjaGNhbmNlbCcsIHVwKS5hZGQobm9kZSwgJ2NvbnRleHRtZW51JywgdXApLmFkZChub2RlLCAnY2xpY2snLCBjbGljaywgdHJ1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpbml0RXZlbnRzLmNsZWFyKCk7XG4gICAgZHJhZ0V2ZW50cy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZERyYWdFdmVudHMoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGlzTW91c2UgPyBvd25lckRvY3VtZW50IDogcm9vdE5vZGU7XG4gICAgZHJhZ0V2ZW50cy5hZGQobm9kZSwgJ3RvdWNobW92ZScsIG1vdmUsIG5vblBhc3NpdmVFdmVudCkuYWRkKG5vZGUsICd0b3VjaGVuZCcsIHVwKS5hZGQobm9kZSwgJ21vdXNlbW92ZScsIG1vdmUsIG5vblBhc3NpdmVFdmVudCkuYWRkKG5vZGUsICdtb3VzZXVwJywgdXApO1xuICB9XG4gIGZ1bmN0aW9uIGlzRm9jdXNOb2RlKG5vZGUpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUgfHwgJyc7XG4gICAgcmV0dXJuIGZvY3VzTm9kZXMuaW5jbHVkZXMobm9kZU5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcmNlQm9vc3QoKSB7XG4gICAgY29uc3QgYm9vc3QgPSBkcmFnRnJlZSA/IGZyZWVGb3JjZUJvb3N0IDogc25hcEZvcmNlQm9vc3Q7XG4gICAgY29uc3QgdHlwZSA9IGlzTW91c2UgPyAnbW91c2UnIDogJ3RvdWNoJztcbiAgICByZXR1cm4gYm9vc3RbdHlwZV07XG4gIH1cbiAgZnVuY3Rpb24gYWxsb3dlZEZvcmNlKGZvcmNlLCB0YXJnZXRDaGFuZ2VkKSB7XG4gICAgY29uc3QgbmV4dCA9IGluZGV4LmFkZChtYXRoU2lnbihmb3JjZSkgKiAtMSk7XG4gICAgY29uc3QgYmFzZUZvcmNlID0gc2Nyb2xsVGFyZ2V0LmJ5RGlzdGFuY2UoZm9yY2UsICFkcmFnRnJlZSkuZGlzdGFuY2U7XG4gICAgaWYgKGRyYWdGcmVlIHx8IG1hdGhBYnMoZm9yY2UpIDwgZ29Ub05leHRUaHJlc2hvbGQpIHJldHVybiBiYXNlRm9yY2U7XG4gICAgaWYgKHNraXBTbmFwcyAmJiB0YXJnZXRDaGFuZ2VkKSByZXR1cm4gYmFzZUZvcmNlICogMC41O1xuICAgIHJldHVybiBzY3JvbGxUYXJnZXQuYnlJbmRleChuZXh0LmdldCgpLCAwKS5kaXN0YW5jZTtcbiAgfVxuICBmdW5jdGlvbiBkb3duKGV2dCkge1xuICAgIGNvbnN0IGlzTW91c2VFdnQgPSBpc01vdXNlRXZlbnQoZXZ0LCBvd25lcldpbmRvdyk7XG4gICAgaXNNb3VzZSA9IGlzTW91c2VFdnQ7XG4gICAgcHJldmVudENsaWNrID0gZHJhZ0ZyZWUgJiYgaXNNb3VzZUV2dCAmJiAhZXZ0LmJ1dHRvbnMgJiYgaXNNb3Zpbmc7XG4gICAgaXNNb3ZpbmcgPSBkZWx0YUFicyh0YXJnZXQuZ2V0KCksIGxvY2F0aW9uLmdldCgpKSA+PSAyO1xuICAgIGlmIChpc01vdXNlRXZ0ICYmIGV2dC5idXR0b24gIT09IDApIHJldHVybjtcbiAgICBpZiAoaXNGb2N1c05vZGUoZXZ0LnRhcmdldCkpIHJldHVybjtcbiAgICBwb2ludGVySXNEb3duID0gdHJ1ZTtcbiAgICBkcmFnVHJhY2tlci5wb2ludGVyRG93bihldnQpO1xuICAgIHNjcm9sbEJvZHkudXNlRnJpY3Rpb24oMCkudXNlRHVyYXRpb24oMCk7XG4gICAgdGFyZ2V0LnNldChsb2NhdGlvbik7XG4gICAgYWRkRHJhZ0V2ZW50cygpO1xuICAgIHN0YXJ0U2Nyb2xsID0gZHJhZ1RyYWNrZXIucmVhZFBvaW50KGV2dCk7XG4gICAgc3RhcnRDcm9zcyA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQsIGNyb3NzQXhpcyk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3BvaW50ZXJEb3duJyk7XG4gIH1cbiAgZnVuY3Rpb24gbW92ZShldnQpIHtcbiAgICBjb25zdCBpc1RvdWNoRXZ0ID0gIWlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KTtcbiAgICBpZiAoaXNUb3VjaEV2dCAmJiBldnQudG91Y2hlcy5sZW5ndGggPj0gMikgcmV0dXJuIHVwKGV2dCk7XG4gICAgY29uc3QgbGFzdFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIGNvbnN0IGxhc3RDcm9zcyA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQsIGNyb3NzQXhpcyk7XG4gICAgY29uc3QgZGlmZlNjcm9sbCA9IGRlbHRhQWJzKGxhc3RTY3JvbGwsIHN0YXJ0U2Nyb2xsKTtcbiAgICBjb25zdCBkaWZmQ3Jvc3MgPSBkZWx0YUFicyhsYXN0Q3Jvc3MsIHN0YXJ0Q3Jvc3MpO1xuICAgIGlmICghcHJldmVudFNjcm9sbCAmJiAhaXNNb3VzZSkge1xuICAgICAgaWYgKCFldnQuY2FuY2VsYWJsZSkgcmV0dXJuIHVwKGV2dCk7XG4gICAgICBwcmV2ZW50U2Nyb2xsID0gZGlmZlNjcm9sbCA+IGRpZmZDcm9zcztcbiAgICAgIGlmICghcHJldmVudFNjcm9sbCkgcmV0dXJuIHVwKGV2dCk7XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBkcmFnVHJhY2tlci5wb2ludGVyTW92ZShldnQpO1xuICAgIGlmIChkaWZmU2Nyb2xsID4gZHJhZ1RocmVzaG9sZCkgcHJldmVudENsaWNrID0gdHJ1ZTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDAuMykudXNlRHVyYXRpb24oMC43NSk7XG4gICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgdGFyZ2V0LmFkZChkaXJlY3Rpb24oZGlmZikpO1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwKGV2dCkge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKDAsIGZhbHNlKTtcbiAgICBjb25zdCB0YXJnZXRDaGFuZ2VkID0gY3VycmVudExvY2F0aW9uLmluZGV4ICE9PSBpbmRleC5nZXQoKTtcbiAgICBjb25zdCByYXdGb3JjZSA9IGRyYWdUcmFja2VyLnBvaW50ZXJVcChldnQpICogZm9yY2VCb29zdCgpO1xuICAgIGNvbnN0IGZvcmNlID0gYWxsb3dlZEZvcmNlKGRpcmVjdGlvbihyYXdGb3JjZSksIHRhcmdldENoYW5nZWQpO1xuICAgIGNvbnN0IGZvcmNlRmFjdG9yID0gZmFjdG9yQWJzKHJhd0ZvcmNlLCBmb3JjZSk7XG4gICAgY29uc3Qgc3BlZWQgPSBiYXNlU3BlZWQgLSAxMCAqIGZvcmNlRmFjdG9yO1xuICAgIGNvbnN0IGZyaWN0aW9uID0gYmFzZUZyaWN0aW9uICsgZm9yY2VGYWN0b3IgLyA1MDtcbiAgICBwcmV2ZW50U2Nyb2xsID0gZmFsc2U7XG4gICAgcG9pbnRlcklzRG93biA9IGZhbHNlO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgICBzY3JvbGxCb2R5LnVzZUR1cmF0aW9uKHNwZWVkKS51c2VGcmljdGlvbihmcmljdGlvbik7XG4gICAgc2Nyb2xsVG8uZGlzdGFuY2UoZm9yY2UsICFkcmFnRnJlZSk7XG4gICAgaXNNb3VzZSA9IGZhbHNlO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyVXAnKTtcbiAgfVxuICBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICBpZiAocHJldmVudENsaWNrKSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHByZXZlbnRDbGljayA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyRG93bigpIHtcbiAgICByZXR1cm4gcG9pbnRlcklzRG93bjtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveSxcbiAgICBwb2ludGVyRG93blxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRHJhZ1RyYWNrZXIoYXhpcywgb3duZXJXaW5kb3cpIHtcbiAgY29uc3QgbG9nSW50ZXJ2YWwgPSAxNzA7XG4gIGxldCBzdGFydEV2ZW50O1xuICBsZXQgbGFzdEV2ZW50O1xuICBmdW5jdGlvbiByZWFkVGltZShldnQpIHtcbiAgICByZXR1cm4gZXZ0LnRpbWVTdGFtcDtcbiAgfVxuICBmdW5jdGlvbiByZWFkUG9pbnQoZXZ0LCBldnRBeGlzKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBldnRBeGlzIHx8IGF4aXMuc2Nyb2xsO1xuICAgIGNvbnN0IGNvb3JkID0gYGNsaWVudCR7cHJvcGVydHkgPT09ICd4JyA/ICdYJyA6ICdZJ31gO1xuICAgIHJldHVybiAoaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpID8gZXZ0IDogZXZ0LnRvdWNoZXNbMF0pW2Nvb3JkXTtcbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyRG93bihldnQpIHtcbiAgICBzdGFydEV2ZW50ID0gZXZ0O1xuICAgIGxhc3RFdmVudCA9IGV2dDtcbiAgICByZXR1cm4gcmVhZFBvaW50KGV2dCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1vdmUoZXZ0KSB7XG4gICAgY29uc3QgZGlmZiA9IHJlYWRQb2ludChldnQpIC0gcmVhZFBvaW50KGxhc3RFdmVudCk7XG4gICAgY29uc3QgZXhwaXJlZCA9IHJlYWRUaW1lKGV2dCkgLSByZWFkVGltZShzdGFydEV2ZW50KSA+IGxvZ0ludGVydmFsO1xuICAgIGxhc3RFdmVudCA9IGV2dDtcbiAgICBpZiAoZXhwaXJlZCkgc3RhcnRFdmVudCA9IGV2dDtcbiAgICByZXR1cm4gZGlmZjtcbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyVXAoZXZ0KSB7XG4gICAgaWYgKCFzdGFydEV2ZW50IHx8ICFsYXN0RXZlbnQpIHJldHVybiAwO1xuICAgIGNvbnN0IGRpZmZEcmFnID0gcmVhZFBvaW50KGxhc3RFdmVudCkgLSByZWFkUG9pbnQoc3RhcnRFdmVudCk7XG4gICAgY29uc3QgZGlmZlRpbWUgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUoc3RhcnRFdmVudCk7XG4gICAgY29uc3QgZXhwaXJlZCA9IHJlYWRUaW1lKGV2dCkgLSByZWFkVGltZShsYXN0RXZlbnQpID4gbG9nSW50ZXJ2YWw7XG4gICAgY29uc3QgZm9yY2UgPSBkaWZmRHJhZyAvIGRpZmZUaW1lO1xuICAgIGNvbnN0IGlzRmxpY2sgPSBkaWZmVGltZSAmJiAhZXhwaXJlZCAmJiBtYXRoQWJzKGZvcmNlKSA+IDAuMTtcbiAgICByZXR1cm4gaXNGbGljayA/IGZvcmNlIDogMDtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHBvaW50ZXJEb3duLFxuICAgIHBvaW50ZXJNb3ZlLFxuICAgIHBvaW50ZXJVcCxcbiAgICByZWFkUG9pbnRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIE5vZGVSZWN0cygpIHtcbiAgZnVuY3Rpb24gbWVhc3VyZShub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0VG9wLFxuICAgICAgb2Zmc2V0TGVmdCxcbiAgICAgIG9mZnNldFdpZHRoLFxuICAgICAgb2Zmc2V0SGVpZ2h0XG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICByaWdodDogb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoLFxuICAgICAgYm90dG9tOiBvZmZzZXRUb3AgKyBvZmZzZXRIZWlnaHQsXG4gICAgICBsZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgd2lkdGg6IG9mZnNldFdpZHRoLFxuICAgICAgaGVpZ2h0OiBvZmZzZXRIZWlnaHRcbiAgICB9O1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBQZXJjZW50T2ZWaWV3KHZpZXdTaXplKSB7XG4gIGZ1bmN0aW9uIG1lYXN1cmUobikge1xuICAgIHJldHVybiB2aWV3U2l6ZSAqIChuIC8gMTAwKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG1lYXN1cmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFJlc2l6ZUhhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIG93bmVyV2luZG93LCBzbGlkZXMsIGF4aXMsIHdhdGNoUmVzaXplLCBub2RlUmVjdHMpIHtcbiAgY29uc3Qgb2JzZXJ2ZU5vZGVzID0gW2NvbnRhaW5lcl0uY29uY2F0KHNsaWRlcyk7XG4gIGxldCByZXNpemVPYnNlcnZlcjtcbiAgbGV0IGNvbnRhaW5lclNpemU7XG4gIGxldCBzbGlkZVNpemVzID0gW107XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gcmVhZFNpemUobm9kZSkge1xuICAgIHJldHVybiBheGlzLm1lYXN1cmVTaXplKG5vZGVSZWN0cy5tZWFzdXJlKG5vZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaFJlc2l6ZSkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclNpemUgPSByZWFkU2l6ZShjb250YWluZXIpO1xuICAgIHNsaWRlU2l6ZXMgPSBzbGlkZXMubWFwKHJlYWRTaXplKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZW50cmllcykge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgaXNDb250YWluZXIgPSBlbnRyeS50YXJnZXQgPT09IGNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IHNsaWRlcy5pbmRleE9mKGVudHJ5LnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGxhc3RTaXplID0gaXNDb250YWluZXIgPyBjb250YWluZXJTaXplIDogc2xpZGVTaXplc1tzbGlkZUluZGV4XTtcbiAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHJlYWRTaXplKGlzQ29udGFpbmVyID8gY29udGFpbmVyIDogc2xpZGVzW3NsaWRlSW5kZXhdKTtcbiAgICAgICAgY29uc3QgZGlmZlNpemUgPSBtYXRoQWJzKG5ld1NpemUgLSBsYXN0U2l6ZSk7XG4gICAgICAgIGlmIChkaWZmU2l6ZSA+PSAwLjUpIHtcbiAgICAgICAgICBlbWJsYUFwaS5yZUluaXQoKTtcbiAgICAgICAgICBldmVudEhhbmRsZXIuZW1pdCgncmVzaXplJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoUmVzaXplKSB8fCB3YXRjaFJlc2l6ZShlbWJsYUFwaSwgZW50cmllcykpIHtcbiAgICAgICAgZGVmYXVsdENhbGxiYWNrKGVudHJpZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG93bmVyV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBvYnNlcnZlTm9kZXMuZm9yRWFjaChub2RlID0+IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZSkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBpZiAocmVzaXplT2JzZXJ2ZXIpIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHByZXZpb3VzTG9jYXRpb24sIHRhcmdldCwgYmFzZUR1cmF0aW9uLCBiYXNlRnJpY3Rpb24pIHtcbiAgbGV0IGJvZHlWZWxvY2l0eSA9IDA7XG4gIGxldCBzY3JvbGxEaXJlY3Rpb24gPSAwO1xuICBsZXQgc2Nyb2xsRHVyYXRpb24gPSBiYXNlRHVyYXRpb247XG4gIGxldCBzY3JvbGxGcmljdGlvbiA9IGJhc2VGcmljdGlvbjtcbiAgbGV0IHJhd0xvY2F0aW9uID0gbG9jYXRpb24uZ2V0KCk7XG4gIGxldCByYXdMb2NhdGlvblByZXZpb3VzID0gMDtcbiAgZnVuY3Rpb24gc2Vlayh0aW1lU3RlcCkge1xuICAgIGNvbnN0IGZpeGVkRGVsdGFUaW1lU2Vjb25kcyA9IHRpbWVTdGVwIC8gMTAwMDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHNjcm9sbER1cmF0aW9uICogZml4ZWREZWx0YVRpbWVTZWNvbmRzO1xuICAgIGNvbnN0IGRpZmYgPSB0YXJnZXQuZ2V0KCkgLSBsb2NhdGlvbi5nZXQoKTtcbiAgICBjb25zdCBpc0luc3RhbnQgPSAhc2Nyb2xsRHVyYXRpb247XG4gICAgbGV0IGRpcmVjdGlvbkRpZmYgPSAwO1xuICAgIGlmIChpc0luc3RhbnQpIHtcbiAgICAgIGJvZHlWZWxvY2l0eSA9IDA7XG4gICAgICBwcmV2aW91c0xvY2F0aW9uLnNldCh0YXJnZXQpO1xuICAgICAgbG9jYXRpb24uc2V0KHRhcmdldCk7XG4gICAgICBkaXJlY3Rpb25EaWZmID0gZGlmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNMb2NhdGlvbi5zZXQobG9jYXRpb24pO1xuICAgICAgYm9keVZlbG9jaXR5ICs9IGRpZmYgLyBkdXJhdGlvbjtcbiAgICAgIGJvZHlWZWxvY2l0eSAqPSBzY3JvbGxGcmljdGlvbjtcbiAgICAgIHJhd0xvY2F0aW9uICs9IGJvZHlWZWxvY2l0eTtcbiAgICAgIGxvY2F0aW9uLmFkZChib2R5VmVsb2NpdHkgKiBmaXhlZERlbHRhVGltZVNlY29uZHMpO1xuICAgICAgZGlyZWN0aW9uRGlmZiA9IHJhd0xvY2F0aW9uIC0gcmF3TG9jYXRpb25QcmV2aW91cztcbiAgICB9XG4gICAgc2Nyb2xsRGlyZWN0aW9uID0gbWF0aFNpZ24oZGlyZWN0aW9uRGlmZik7XG4gICAgcmF3TG9jYXRpb25QcmV2aW91cyA9IHJhd0xvY2F0aW9uO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHNldHRsZWQoKSB7XG4gICAgY29uc3QgZGlmZiA9IHRhcmdldC5nZXQoKSAtIG9mZnNldExvY2F0aW9uLmdldCgpO1xuICAgIHJldHVybiBtYXRoQWJzKGRpZmYpIDwgMC4wMDE7XG4gIH1cbiAgZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHNjcm9sbER1cmF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gc2Nyb2xsRGlyZWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIHZlbG9jaXR5KCkge1xuICAgIHJldHVybiBib2R5VmVsb2NpdHk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQmFzZUR1cmF0aW9uKCkge1xuICAgIHJldHVybiB1c2VEdXJhdGlvbihiYXNlRHVyYXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUJhc2VGcmljdGlvbigpIHtcbiAgICByZXR1cm4gdXNlRnJpY3Rpb24oYmFzZUZyaWN0aW9uKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VEdXJhdGlvbihuKSB7XG4gICAgc2Nyb2xsRHVyYXRpb24gPSBuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUZyaWN0aW9uKG4pIHtcbiAgICBzY3JvbGxGcmljdGlvbiA9IG47XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBkaXJlY3Rpb24sXG4gICAgZHVyYXRpb24sXG4gICAgdmVsb2NpdHksXG4gICAgc2VlayxcbiAgICBzZXR0bGVkLFxuICAgIHVzZUJhc2VGcmljdGlvbixcbiAgICB1c2VCYXNlRHVyYXRpb24sXG4gICAgdXNlRnJpY3Rpb24sXG4gICAgdXNlRHVyYXRpb25cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbEJvdW5kcyhsaW1pdCwgbG9jYXRpb24sIHRhcmdldCwgc2Nyb2xsQm9keSwgcGVyY2VudE9mVmlldykge1xuICBjb25zdCBwdWxsQmFja1RocmVzaG9sZCA9IHBlcmNlbnRPZlZpZXcubWVhc3VyZSgxMCk7XG4gIGNvbnN0IGVkZ2VPZmZzZXRUb2xlcmFuY2UgPSBwZXJjZW50T2ZWaWV3Lm1lYXN1cmUoNTApO1xuICBjb25zdCBmcmljdGlvbkxpbWl0ID0gTGltaXQoMC4xLCAwLjk5KTtcbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHNob3VsZENvbnN0cmFpbigpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWxpbWl0LnJlYWNoZWRBbnkodGFyZ2V0LmdldCgpKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghbGltaXQucmVhY2hlZEFueShsb2NhdGlvbi5nZXQoKSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjb25zdHJhaW4ocG9pbnRlckRvd24pIHtcbiAgICBpZiAoIXNob3VsZENvbnN0cmFpbigpKSByZXR1cm47XG4gICAgY29uc3QgZWRnZSA9IGxpbWl0LnJlYWNoZWRNaW4obG9jYXRpb24uZ2V0KCkpID8gJ21pbicgOiAnbWF4JztcbiAgICBjb25zdCBkaWZmVG9FZGdlID0gbWF0aEFicyhsaW1pdFtlZGdlXSAtIGxvY2F0aW9uLmdldCgpKTtcbiAgICBjb25zdCBkaWZmVG9UYXJnZXQgPSB0YXJnZXQuZ2V0KCkgLSBsb2NhdGlvbi5nZXQoKTtcbiAgICBjb25zdCBmcmljdGlvbiA9IGZyaWN0aW9uTGltaXQuY29uc3RyYWluKGRpZmZUb0VkZ2UgLyBlZGdlT2Zmc2V0VG9sZXJhbmNlKTtcbiAgICB0YXJnZXQuc3VidHJhY3QoZGlmZlRvVGFyZ2V0ICogZnJpY3Rpb24pO1xuICAgIGlmICghcG9pbnRlckRvd24gJiYgbWF0aEFicyhkaWZmVG9UYXJnZXQpIDwgcHVsbEJhY2tUaHJlc2hvbGQpIHtcbiAgICAgIHRhcmdldC5zZXQobGltaXQuY29uc3RyYWluKHRhcmdldC5nZXQoKSkpO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigyNSkudXNlQmFzZUZyaWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUFjdGl2ZShhY3RpdmUpIHtcbiAgICBkaXNhYmxlZCA9ICFhY3RpdmU7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzaG91bGRDb25zdHJhaW4sXG4gICAgY29uc3RyYWluLFxuICAgIHRvZ2dsZUFjdGl2ZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsQ29udGFpbih2aWV3U2l6ZSwgY29udGVudFNpemUsIHNuYXBzQWxpZ25lZCwgY29udGFpblNjcm9sbCwgcGl4ZWxUb2xlcmFuY2UpIHtcbiAgY29uc3Qgc2Nyb2xsQm91bmRzID0gTGltaXQoLWNvbnRlbnRTaXplICsgdmlld1NpemUsIDApO1xuICBjb25zdCBzbmFwc0JvdW5kZWQgPSBtZWFzdXJlQm91bmRlZCgpO1xuICBjb25zdCBzY3JvbGxDb250YWluTGltaXQgPSBmaW5kU2Nyb2xsQ29udGFpbkxpbWl0KCk7XG4gIGNvbnN0IHNuYXBzQ29udGFpbmVkID0gbWVhc3VyZUNvbnRhaW5lZCgpO1xuICBmdW5jdGlvbiB1c2VQaXhlbFRvbGVyYW5jZShib3VuZCwgc25hcCkge1xuICAgIHJldHVybiBkZWx0YUFicyhib3VuZCwgc25hcCkgPCAxO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRTY3JvbGxDb250YWluTGltaXQoKSB7XG4gICAgY29uc3Qgc3RhcnRTbmFwID0gc25hcHNCb3VuZGVkWzBdO1xuICAgIGNvbnN0IGVuZFNuYXAgPSBhcnJheUxhc3Qoc25hcHNCb3VuZGVkKTtcbiAgICBjb25zdCBtaW4gPSBzbmFwc0JvdW5kZWQubGFzdEluZGV4T2Yoc3RhcnRTbmFwKTtcbiAgICBjb25zdCBtYXggPSBzbmFwc0JvdW5kZWQuaW5kZXhPZihlbmRTbmFwKSArIDE7XG4gICAgcmV0dXJuIExpbWl0KG1pbiwgbWF4KTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlQm91bmRlZCgpIHtcbiAgICByZXR1cm4gc25hcHNBbGlnbmVkLm1hcCgoc25hcEFsaWduZWQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1pbixcbiAgICAgICAgbWF4XG4gICAgICB9ID0gc2Nyb2xsQm91bmRzO1xuICAgICAgY29uc3Qgc25hcCA9IHNjcm9sbEJvdW5kcy5jb25zdHJhaW4oc25hcEFsaWduZWQpO1xuICAgICAgY29uc3QgaXNGaXJzdCA9ICFpbmRleDtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IGFycmF5SXNMYXN0SW5kZXgoc25hcHNBbGlnbmVkLCBpbmRleCk7XG4gICAgICBpZiAoaXNGaXJzdCkgcmV0dXJuIG1heDtcbiAgICAgIGlmIChpc0xhc3QpIHJldHVybiBtaW47XG4gICAgICBpZiAodXNlUGl4ZWxUb2xlcmFuY2UobWluLCBzbmFwKSkgcmV0dXJuIG1pbjtcbiAgICAgIGlmICh1c2VQaXhlbFRvbGVyYW5jZShtYXgsIHNuYXApKSByZXR1cm4gbWF4O1xuICAgICAgcmV0dXJuIHNuYXA7XG4gICAgfSkubWFwKHNjcm9sbEJvdW5kID0+IHBhcnNlRmxvYXQoc2Nyb2xsQm91bmQudG9GaXhlZCgzKSkpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVDb250YWluZWQoKSB7XG4gICAgaWYgKGNvbnRlbnRTaXplIDw9IHZpZXdTaXplICsgcGl4ZWxUb2xlcmFuY2UpIHJldHVybiBbc2Nyb2xsQm91bmRzLm1heF07XG4gICAgaWYgKGNvbnRhaW5TY3JvbGwgPT09ICdrZWVwU25hcHMnKSByZXR1cm4gc25hcHNCb3VuZGVkO1xuICAgIGNvbnN0IHtcbiAgICAgIG1pbixcbiAgICAgIG1heFxuICAgIH0gPSBzY3JvbGxDb250YWluTGltaXQ7XG4gICAgcmV0dXJuIHNuYXBzQm91bmRlZC5zbGljZShtaW4sIG1heCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbmFwc0NvbnRhaW5lZCxcbiAgICBzY3JvbGxDb250YWluTGltaXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbExpbWl0KGNvbnRlbnRTaXplLCBzY3JvbGxTbmFwcywgbG9vcCkge1xuICBjb25zdCBtYXggPSBzY3JvbGxTbmFwc1swXTtcbiAgY29uc3QgbWluID0gbG9vcCA/IG1heCAtIGNvbnRlbnRTaXplIDogYXJyYXlMYXN0KHNjcm9sbFNuYXBzKTtcbiAgY29uc3QgbGltaXQgPSBMaW1pdChtaW4sIG1heCk7XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbGltaXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbExvb3Blcihjb250ZW50U2l6ZSwgbGltaXQsIGxvY2F0aW9uLCB2ZWN0b3JzKSB7XG4gIGNvbnN0IGpvaW50U2FmZXR5ID0gMC4xO1xuICBjb25zdCBtaW4gPSBsaW1pdC5taW4gKyBqb2ludFNhZmV0eTtcbiAgY29uc3QgbWF4ID0gbGltaXQubWF4ICsgam9pbnRTYWZldHk7XG4gIGNvbnN0IHtcbiAgICByZWFjaGVkTWluLFxuICAgIHJlYWNoZWRNYXhcbiAgfSA9IExpbWl0KG1pbiwgbWF4KTtcbiAgZnVuY3Rpb24gc2hvdWxkTG9vcChkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAxKSByZXR1cm4gcmVhY2hlZE1heChsb2NhdGlvbi5nZXQoKSk7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gLTEpIHJldHVybiByZWFjaGVkTWluKGxvY2F0aW9uLmdldCgpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gbG9vcChkaXJlY3Rpb24pIHtcbiAgICBpZiAoIXNob3VsZExvb3AoZGlyZWN0aW9uKSkgcmV0dXJuO1xuICAgIGNvbnN0IGxvb3BEaXN0YW5jZSA9IGNvbnRlbnRTaXplICogKGRpcmVjdGlvbiAqIC0xKTtcbiAgICB2ZWN0b3JzLmZvckVhY2godiA9PiB2LmFkZChsb29wRGlzdGFuY2UpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGxvb3BcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFByb2dyZXNzKGxpbWl0KSB7XG4gIGNvbnN0IHtcbiAgICBtYXgsXG4gICAgbGVuZ3RoXG4gIH0gPSBsaW1pdDtcbiAgZnVuY3Rpb24gZ2V0KG4pIHtcbiAgICBjb25zdCBjdXJyZW50TG9jYXRpb24gPSBuIC0gbWF4O1xuICAgIHJldHVybiBsZW5ndGggPyBjdXJyZW50TG9jYXRpb24gLyAtbGVuZ3RoIDogMDtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGdldFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsU25hcHMoYXhpcywgYWxpZ25tZW50LCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXNUb1Njcm9sbCkge1xuICBjb25zdCB7XG4gICAgc3RhcnRFZGdlLFxuICAgIGVuZEVkZ2VcbiAgfSA9IGF4aXM7XG4gIGNvbnN0IHtcbiAgICBncm91cFNsaWRlc1xuICB9ID0gc2xpZGVzVG9TY3JvbGw7XG4gIGNvbnN0IGFsaWdubWVudHMgPSBtZWFzdXJlU2l6ZXMoKS5tYXAoYWxpZ25tZW50Lm1lYXN1cmUpO1xuICBjb25zdCBzbmFwcyA9IG1lYXN1cmVVbmFsaWduZWQoKTtcbiAgY29uc3Qgc25hcHNBbGlnbmVkID0gbWVhc3VyZUFsaWduZWQoKTtcbiAgZnVuY3Rpb24gbWVhc3VyZVNpemVzKCkge1xuICAgIHJldHVybiBncm91cFNsaWRlcyhzbGlkZVJlY3RzKS5tYXAocmVjdHMgPT4gYXJyYXlMYXN0KHJlY3RzKVtlbmRFZGdlXSAtIHJlY3RzWzBdW3N0YXJ0RWRnZV0pLm1hcChtYXRoQWJzKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlVW5hbGlnbmVkKCkge1xuICAgIHJldHVybiBzbGlkZVJlY3RzLm1hcChyZWN0ID0+IGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHJlY3Rbc3RhcnRFZGdlXSkubWFwKHNuYXAgPT4gLW1hdGhBYnMoc25hcCkpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVBbGlnbmVkKCkge1xuICAgIHJldHVybiBncm91cFNsaWRlcyhzbmFwcykubWFwKGcgPT4gZ1swXSkubWFwKChzbmFwLCBpbmRleCkgPT4gc25hcCArIGFsaWdubWVudHNbaW5kZXhdKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNuYXBzLFxuICAgIHNuYXBzQWxpZ25lZFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVSZWdpc3RyeShjb250YWluU25hcHMsIGNvbnRhaW5TY3JvbGwsIHNjcm9sbFNuYXBzLCBzY3JvbGxDb250YWluTGltaXQsIHNsaWRlc1RvU2Nyb2xsLCBzbGlkZUluZGV4ZXMpIHtcbiAgY29uc3Qge1xuICAgIGdyb3VwU2xpZGVzXG4gIH0gPSBzbGlkZXNUb1Njcm9sbDtcbiAgY29uc3Qge1xuICAgIG1pbixcbiAgICBtYXhcbiAgfSA9IHNjcm9sbENvbnRhaW5MaW1pdDtcbiAgY29uc3Qgc2xpZGVSZWdpc3RyeSA9IGNyZWF0ZVNsaWRlUmVnaXN0cnkoKTtcbiAgZnVuY3Rpb24gY3JlYXRlU2xpZGVSZWdpc3RyeSgpIHtcbiAgICBjb25zdCBncm91cGVkU2xpZGVJbmRleGVzID0gZ3JvdXBTbGlkZXMoc2xpZGVJbmRleGVzKTtcbiAgICBjb25zdCBkb05vdENvbnRhaW4gPSAhY29udGFpblNuYXBzIHx8IGNvbnRhaW5TY3JvbGwgPT09ICdrZWVwU25hcHMnO1xuICAgIGlmIChzY3JvbGxTbmFwcy5sZW5ndGggPT09IDEpIHJldHVybiBbc2xpZGVJbmRleGVzXTtcbiAgICBpZiAoZG9Ob3RDb250YWluKSByZXR1cm4gZ3JvdXBlZFNsaWRlSW5kZXhlcztcbiAgICByZXR1cm4gZ3JvdXBlZFNsaWRlSW5kZXhlcy5zbGljZShtaW4sIG1heCkubWFwKChncm91cCwgaW5kZXgsIGdyb3VwcykgPT4ge1xuICAgICAgY29uc3QgaXNGaXJzdCA9ICFpbmRleDtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IGFycmF5SXNMYXN0SW5kZXgoZ3JvdXBzLCBpbmRleCk7XG4gICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IGFycmF5TGFzdChncm91cHNbMF0pICsgMTtcbiAgICAgICAgcmV0dXJuIGFycmF5RnJvbU51bWJlcihyYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gYXJyYXlMYXN0SW5kZXgoc2xpZGVJbmRleGVzKSAtIGFycmF5TGFzdChncm91cHMpWzBdICsgMTtcbiAgICAgICAgcmV0dXJuIGFycmF5RnJvbU51bWJlcihyYW5nZSwgYXJyYXlMYXN0KGdyb3VwcylbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc2xpZGVSZWdpc3RyeVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsVGFyZ2V0KGxvb3AsIHNjcm9sbFNuYXBzLCBjb250ZW50U2l6ZSwgbGltaXQsIHRhcmdldFZlY3Rvcikge1xuICBjb25zdCB7XG4gICAgcmVhY2hlZEFueSxcbiAgICByZW1vdmVPZmZzZXQsXG4gICAgY29uc3RyYWluXG4gIH0gPSBsaW1pdDtcbiAgZnVuY3Rpb24gbWluRGlzdGFuY2UoZGlzdGFuY2VzKSB7XG4gICAgcmV0dXJuIGRpc3RhbmNlcy5jb25jYXQoKS5zb3J0KChhLCBiKSA9PiBtYXRoQWJzKGEpIC0gbWF0aEFicyhiKSlbMF07XG4gIH1cbiAgZnVuY3Rpb24gZmluZFRhcmdldFNuYXAodGFyZ2V0KSB7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBsb29wID8gcmVtb3ZlT2Zmc2V0KHRhcmdldCkgOiBjb25zdHJhaW4odGFyZ2V0KTtcbiAgICBjb25zdCBhc2NEaWZmc1RvU25hcHMgPSBzY3JvbGxTbmFwcy5tYXAoKHNuYXAsIGluZGV4KSA9PiAoe1xuICAgICAgZGlmZjogc2hvcnRjdXQoc25hcCAtIGRpc3RhbmNlLCAwKSxcbiAgICAgIGluZGV4XG4gICAgfSkpLnNvcnQoKGQxLCBkMikgPT4gbWF0aEFicyhkMS5kaWZmKSAtIG1hdGhBYnMoZDIuZGlmZikpO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4XG4gICAgfSA9IGFzY0RpZmZzVG9TbmFwc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc2hvcnRjdXQodGFyZ2V0LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB0YXJnZXRzID0gW3RhcmdldCwgdGFyZ2V0ICsgY29udGVudFNpemUsIHRhcmdldCAtIGNvbnRlbnRTaXplXTtcbiAgICBpZiAoIWxvb3ApIHJldHVybiB0YXJnZXQ7XG4gICAgaWYgKCFkaXJlY3Rpb24pIHJldHVybiBtaW5EaXN0YW5jZSh0YXJnZXRzKTtcbiAgICBjb25zdCBtYXRjaGluZ1RhcmdldHMgPSB0YXJnZXRzLmZpbHRlcih0ID0+IG1hdGhTaWduKHQpID09PSBkaXJlY3Rpb24pO1xuICAgIGlmIChtYXRjaGluZ1RhcmdldHMubGVuZ3RoKSByZXR1cm4gbWluRGlzdGFuY2UobWF0Y2hpbmdUYXJnZXRzKTtcbiAgICByZXR1cm4gYXJyYXlMYXN0KHRhcmdldHMpIC0gY29udGVudFNpemU7XG4gIH1cbiAgZnVuY3Rpb24gYnlJbmRleChpbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgZGlmZlRvU25hcCA9IHNjcm9sbFNuYXBzW2luZGV4XSAtIHRhcmdldFZlY3Rvci5nZXQoKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IHNob3J0Y3V0KGRpZmZUb1NuYXAsIGRpcmVjdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2VcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ5RGlzdGFuY2UoZGlzdGFuY2UsIHNuYXApIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRWZWN0b3IuZ2V0KCkgKyBkaXN0YW5jZTtcbiAgICBjb25zdCB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlOiB0YXJnZXRTbmFwRGlzdGFuY2VcbiAgICB9ID0gZmluZFRhcmdldFNuYXAodGFyZ2V0KTtcbiAgICBjb25zdCByZWFjaGVkQm91bmQgPSAhbG9vcCAmJiByZWFjaGVkQW55KHRhcmdldCk7XG4gICAgaWYgKCFzbmFwIHx8IHJlYWNoZWRCb3VuZCkgcmV0dXJuIHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2VcbiAgICB9O1xuICAgIGNvbnN0IGRpZmZUb1NuYXAgPSBzY3JvbGxTbmFwc1tpbmRleF0gLSB0YXJnZXRTbmFwRGlzdGFuY2U7XG4gICAgY29uc3Qgc25hcERpc3RhbmNlID0gZGlzdGFuY2UgKyBzaG9ydGN1dChkaWZmVG9TbmFwLCAwKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZTogc25hcERpc3RhbmNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGJ5RGlzdGFuY2UsXG4gICAgYnlJbmRleCxcbiAgICBzaG9ydGN1dFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsVG8oYW5pbWF0aW9uLCBpbmRleEN1cnJlbnQsIGluZGV4UHJldmlvdXMsIHNjcm9sbEJvZHksIHNjcm9sbFRhcmdldCwgdGFyZ2V0VmVjdG9yLCBldmVudEhhbmRsZXIpIHtcbiAgZnVuY3Rpb24gc2Nyb2xsVG8odGFyZ2V0KSB7XG4gICAgY29uc3QgZGlzdGFuY2VEaWZmID0gdGFyZ2V0LmRpc3RhbmNlO1xuICAgIGNvbnN0IGluZGV4RGlmZiA9IHRhcmdldC5pbmRleCAhPT0gaW5kZXhDdXJyZW50LmdldCgpO1xuICAgIHRhcmdldFZlY3Rvci5hZGQoZGlzdGFuY2VEaWZmKTtcbiAgICBpZiAoZGlzdGFuY2VEaWZmKSB7XG4gICAgICBpZiAoc2Nyb2xsQm9keS5kdXJhdGlvbigpKSB7XG4gICAgICAgIGFuaW1hdGlvbi5zdGFydCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZSgpO1xuICAgICAgICBhbmltYXRpb24ucmVuZGVyKDEpO1xuICAgICAgICBhbmltYXRpb24udXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmRleERpZmYpIHtcbiAgICAgIGluZGV4UHJldmlvdXMuc2V0KGluZGV4Q3VycmVudC5nZXQoKSk7XG4gICAgICBpbmRleEN1cnJlbnQuc2V0KHRhcmdldC5pbmRleCk7XG4gICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2VsZWN0Jyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRpc3RhbmNlKG4sIHNuYXApIHtcbiAgICBjb25zdCB0YXJnZXQgPSBzY3JvbGxUYXJnZXQuYnlEaXN0YW5jZShuLCBzbmFwKTtcbiAgICBzY3JvbGxUbyh0YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGluZGV4KG4sIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHRhcmdldEluZGV4ID0gaW5kZXhDdXJyZW50LmNsb25lKCkuc2V0KG4pO1xuICAgIGNvbnN0IHRhcmdldCA9IHNjcm9sbFRhcmdldC5ieUluZGV4KHRhcmdldEluZGV4LmdldCgpLCBkaXJlY3Rpb24pO1xuICAgIHNjcm9sbFRvKHRhcmdldCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBkaXN0YW5jZSxcbiAgICBpbmRleFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVGb2N1cyhyb290LCBzbGlkZXMsIHNsaWRlUmVnaXN0cnksIHNjcm9sbFRvLCBzY3JvbGxCb2R5LCBldmVudFN0b3JlLCBldmVudEhhbmRsZXIsIHdhdGNoRm9jdXMpIHtcbiAgY29uc3QgZm9jdXNMaXN0ZW5lck9wdGlvbnMgPSB7XG4gICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICBjYXB0dXJlOiB0cnVlXG4gIH07XG4gIGxldCBsYXN0VGFiUHJlc3NUaW1lID0gMDtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSkge1xuICAgIGlmICghd2F0Y2hGb2N1cykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRDYWxsYmFjayhpbmRleCkge1xuICAgICAgY29uc3Qgbm93VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgZGlmZlRpbWUgPSBub3dUaW1lIC0gbGFzdFRhYlByZXNzVGltZTtcbiAgICAgIGlmIChkaWZmVGltZSA+IDEwKSByZXR1cm47XG4gICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2xpZGVGb2N1c1N0YXJ0Jyk7XG4gICAgICByb290LnNjcm9sbExlZnQgPSAwO1xuICAgICAgY29uc3QgZ3JvdXAgPSBzbGlkZVJlZ2lzdHJ5LmZpbmRJbmRleChncm91cCA9PiBncm91cC5pbmNsdWRlcyhpbmRleCkpO1xuICAgICAgaWYgKCFpc051bWJlcihncm91cCkpIHJldHVybjtcbiAgICAgIHNjcm9sbEJvZHkudXNlRHVyYXRpb24oMCk7XG4gICAgICBzY3JvbGxUby5pbmRleChncm91cCwgMCk7XG4gICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2xpZGVGb2N1cycpO1xuICAgIH1cbiAgICBldmVudFN0b3JlLmFkZChkb2N1bWVudCwgJ2tleWRvd24nLCByZWdpc3RlclRhYlByZXNzLCBmYWxzZSk7XG4gICAgc2xpZGVzLmZvckVhY2goKHNsaWRlLCBzbGlkZUluZGV4KSA9PiB7XG4gICAgICBldmVudFN0b3JlLmFkZChzbGlkZSwgJ2ZvY3VzJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaEZvY3VzKSB8fCB3YXRjaEZvY3VzKGVtYmxhQXBpLCBldnQpKSB7XG4gICAgICAgICAgZGVmYXVsdENhbGxiYWNrKHNsaWRlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LCBmb2N1c0xpc3RlbmVyT3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJUYWJQcmVzcyhldmVudCkge1xuICAgIGlmIChldmVudC5jb2RlID09PSAnVGFiJykgbGFzdFRhYlByZXNzVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gVmVjdG9yMUQoaW5pdGlhbFZhbHVlKSB7XG4gIGxldCB2YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBzZXQobikge1xuICAgIHZhbHVlID0gbm9ybWFsaXplSW5wdXQobik7XG4gIH1cbiAgZnVuY3Rpb24gYWRkKG4pIHtcbiAgICB2YWx1ZSArPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJ0cmFjdChuKSB7XG4gICAgdmFsdWUgLT0gbm9ybWFsaXplSW5wdXQobik7XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXplSW5wdXQobikge1xuICAgIHJldHVybiBpc051bWJlcihuKSA/IG4gOiBuLmdldCgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0LFxuICAgIHNldCxcbiAgICBhZGQsXG4gICAgc3VidHJhY3RcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFRyYW5zbGF0ZShheGlzLCBjb250YWluZXIpIHtcbiAgY29uc3QgdHJhbnNsYXRlID0gYXhpcy5zY3JvbGwgPT09ICd4JyA/IHggOiB5O1xuICBjb25zdCBjb250YWluZXJTdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHgobikge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoJHtufXB4LDBweCwwcHgpYDtcbiAgfVxuICBmdW5jdGlvbiB5KG4pIHtcbiAgICByZXR1cm4gYHRyYW5zbGF0ZTNkKDBweCwke259cHgsMHB4KWA7XG4gIH1cbiAgZnVuY3Rpb24gdG8odGFyZ2V0KSB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtID0gdHJhbnNsYXRlKGF4aXMuZGlyZWN0aW9uKHRhcmdldCkpO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUFjdGl2ZShhY3RpdmUpIHtcbiAgICBkaXNhYmxlZCA9ICFhY3RpdmU7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgaWYgKCFjb250YWluZXIuZ2V0QXR0cmlidXRlKCdzdHlsZScpKSBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgY2xlYXIsXG4gICAgdG8sXG4gICAgdG9nZ2xlQWN0aXZlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZUxvb3BlcihheGlzLCB2aWV3U2l6ZSwgY29udGVudFNpemUsIHNsaWRlU2l6ZXMsIHNsaWRlU2l6ZXNXaXRoR2Fwcywgc25hcHMsIHNjcm9sbFNuYXBzLCBsb2NhdGlvbiwgc2xpZGVzKSB7XG4gIGNvbnN0IHJvdW5kaW5nU2FmZXR5ID0gMC41O1xuICBjb25zdCBhc2NJdGVtcyA9IGFycmF5S2V5cyhzbGlkZVNpemVzV2l0aEdhcHMpO1xuICBjb25zdCBkZXNjSXRlbXMgPSBhcnJheUtleXMoc2xpZGVTaXplc1dpdGhHYXBzKS5yZXZlcnNlKCk7XG4gIGNvbnN0IGxvb3BQb2ludHMgPSBzdGFydFBvaW50cygpLmNvbmNhdChlbmRQb2ludHMoKSk7XG4gIGZ1bmN0aW9uIHJlbW92ZVNsaWRlU2l6ZXMoaW5kZXhlcywgZnJvbSkge1xuICAgIHJldHVybiBpbmRleGVzLnJlZHVjZSgoYSwgaSkgPT4ge1xuICAgICAgcmV0dXJuIGEgLSBzbGlkZVNpemVzV2l0aEdhcHNbaV07XG4gICAgfSwgZnJvbSk7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVzSW5HYXAoaW5kZXhlcywgZ2FwKSB7XG4gICAgcmV0dXJuIGluZGV4ZXMucmVkdWNlKChhLCBpKSA9PiB7XG4gICAgICBjb25zdCByZW1haW5pbmdHYXAgPSByZW1vdmVTbGlkZVNpemVzKGEsIGdhcCk7XG4gICAgICByZXR1cm4gcmVtYWluaW5nR2FwID4gMCA/IGEuY29uY2F0KFtpXSkgOiBhO1xuICAgIH0sIFtdKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kU2xpZGVCb3VuZHMob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHNuYXBzLm1hcCgoc25hcCwgaW5kZXgpID0+ICh7XG4gICAgICBzdGFydDogc25hcCAtIHNsaWRlU2l6ZXNbaW5kZXhdICsgcm91bmRpbmdTYWZldHkgKyBvZmZzZXQsXG4gICAgICBlbmQ6IHNuYXAgKyB2aWV3U2l6ZSAtIHJvdW5kaW5nU2FmZXR5ICsgb2Zmc2V0XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRMb29wUG9pbnRzKGluZGV4ZXMsIG9mZnNldCwgaXNFbmRFZGdlKSB7XG4gICAgY29uc3Qgc2xpZGVCb3VuZHMgPSBmaW5kU2xpZGVCb3VuZHMob2Zmc2V0KTtcbiAgICByZXR1cm4gaW5kZXhlcy5tYXAoaW5kZXggPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbCA9IGlzRW5kRWRnZSA/IDAgOiAtY29udGVudFNpemU7XG4gICAgICBjb25zdCBhbHRlcmVkID0gaXNFbmRFZGdlID8gY29udGVudFNpemUgOiAwO1xuICAgICAgY29uc3QgYm91bmRFZGdlID0gaXNFbmRFZGdlID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgICAgY29uc3QgbG9vcFBvaW50ID0gc2xpZGVCb3VuZHNbaW5kZXhdW2JvdW5kRWRnZV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleCxcbiAgICAgICAgbG9vcFBvaW50LFxuICAgICAgICBzbGlkZUxvY2F0aW9uOiBWZWN0b3IxRCgtMSksXG4gICAgICAgIHRyYW5zbGF0ZTogVHJhbnNsYXRlKGF4aXMsIHNsaWRlc1tpbmRleF0pLFxuICAgICAgICB0YXJnZXQ6ICgpID0+IGxvY2F0aW9uLmdldCgpID4gbG9vcFBvaW50ID8gaW5pdGlhbCA6IGFsdGVyZWRcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRQb2ludHMoKSB7XG4gICAgY29uc3QgZ2FwID0gc2Nyb2xsU25hcHNbMF07XG4gICAgY29uc3QgaW5kZXhlcyA9IHNsaWRlc0luR2FwKGRlc2NJdGVtcywgZ2FwKTtcbiAgICByZXR1cm4gZmluZExvb3BQb2ludHMoaW5kZXhlcywgY29udGVudFNpemUsIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBlbmRQb2ludHMoKSB7XG4gICAgY29uc3QgZ2FwID0gdmlld1NpemUgLSBzY3JvbGxTbmFwc1swXSAtIDE7XG4gICAgY29uc3QgaW5kZXhlcyA9IHNsaWRlc0luR2FwKGFzY0l0ZW1zLCBnYXApO1xuICAgIHJldHVybiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCAtY29udGVudFNpemUsIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGNhbkxvb3AoKSB7XG4gICAgcmV0dXJuIGxvb3BQb2ludHMuZXZlcnkoKHtcbiAgICAgIGluZGV4XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3Qgb3RoZXJJbmRleGVzID0gYXNjSXRlbXMuZmlsdGVyKGkgPT4gaSAhPT0gaW5kZXgpO1xuICAgICAgcmV0dXJuIHJlbW92ZVNsaWRlU2l6ZXMob3RoZXJJbmRleGVzLCB2aWV3U2l6ZSkgPD0gMC4xO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgbG9vcFBvaW50cy5mb3JFYWNoKGxvb3BQb2ludCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdHJhbnNsYXRlLFxuICAgICAgICBzbGlkZUxvY2F0aW9uXG4gICAgICB9ID0gbG9vcFBvaW50O1xuICAgICAgY29uc3Qgc2hpZnRMb2NhdGlvbiA9IHRhcmdldCgpO1xuICAgICAgaWYgKHNoaWZ0TG9jYXRpb24gPT09IHNsaWRlTG9jYXRpb24uZ2V0KCkpIHJldHVybjtcbiAgICAgIHRyYW5zbGF0ZS50byhzaGlmdExvY2F0aW9uKTtcbiAgICAgIHNsaWRlTG9jYXRpb24uc2V0KHNoaWZ0TG9jYXRpb24pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGxvb3BQb2ludHMuZm9yRWFjaChsb29wUG9pbnQgPT4gbG9vcFBvaW50LnRyYW5zbGF0ZS5jbGVhcigpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNhbkxvb3AsXG4gICAgY2xlYXIsXG4gICAgbG9vcCxcbiAgICBsb29wUG9pbnRzXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZXNIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCB3YXRjaFNsaWRlcykge1xuICBsZXQgbXV0YXRpb25PYnNlcnZlcjtcbiAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaFNsaWRlcykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRDYWxsYmFjayhtdXRhdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgIGVtYmxhQXBpLnJlSW5pdCgpO1xuICAgICAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZXNDaGFuZ2VkJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoU2xpZGVzKSB8fCB3YXRjaFNsaWRlcyhlbWJsYUFwaSwgbXV0YXRpb25zKSkge1xuICAgICAgICBkZWZhdWx0Q2FsbGJhY2sobXV0YXRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyLCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmIChtdXRhdGlvbk9ic2VydmVyKSBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZXNJblZpZXcoY29udGFpbmVyLCBzbGlkZXMsIGV2ZW50SGFuZGxlciwgdGhyZXNob2xkKSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbkVudHJ5TWFwID0ge307XG4gIGxldCBpblZpZXdDYWNoZSA9IG51bGw7XG4gIGxldCBub3RJblZpZXdDYWNoZSA9IG51bGw7XG4gIGxldCBpbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzbGlkZXMuaW5kZXhPZihlbnRyeS50YXJnZXQpO1xuICAgICAgICBpbnRlcnNlY3Rpb25FbnRyeU1hcFtpbmRleF0gPSBlbnRyeTtcbiAgICAgIH0pO1xuICAgICAgaW5WaWV3Q2FjaGUgPSBudWxsO1xuICAgICAgbm90SW5WaWV3Q2FjaGUgPSBudWxsO1xuICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NsaWRlc0luVmlldycpO1xuICAgIH0sIHtcbiAgICAgIHJvb3Q6IGNvbnRhaW5lci5wYXJlbnRFbGVtZW50LFxuICAgICAgdGhyZXNob2xkXG4gICAgfSk7XG4gICAgc2xpZGVzLmZvckVhY2goc2xpZGUgPT4gaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShzbGlkZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKGludGVyc2VjdGlvbk9ic2VydmVyKSBpbnRlcnNlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJblZpZXdMaXN0KGluVmlldykge1xuICAgIHJldHVybiBvYmplY3RLZXlzKGludGVyc2VjdGlvbkVudHJ5TWFwKS5yZWR1Y2UoKGxpc3QsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoc2xpZGVJbmRleCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzSW50ZXJzZWN0aW5nXG4gICAgICB9ID0gaW50ZXJzZWN0aW9uRW50cnlNYXBbaW5kZXhdO1xuICAgICAgY29uc3QgaW5WaWV3TWF0Y2ggPSBpblZpZXcgJiYgaXNJbnRlcnNlY3Rpbmc7XG4gICAgICBjb25zdCBub3RJblZpZXdNYXRjaCA9ICFpblZpZXcgJiYgIWlzSW50ZXJzZWN0aW5nO1xuICAgICAgaWYgKGluVmlld01hdGNoIHx8IG5vdEluVmlld01hdGNoKSBsaXN0LnB1c2goaW5kZXgpO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIGdldChpblZpZXcgPSB0cnVlKSB7XG4gICAgaWYgKGluVmlldyAmJiBpblZpZXdDYWNoZSkgcmV0dXJuIGluVmlld0NhY2hlO1xuICAgIGlmICghaW5WaWV3ICYmIG5vdEluVmlld0NhY2hlKSByZXR1cm4gbm90SW5WaWV3Q2FjaGU7XG4gICAgY29uc3Qgc2xpZGVJbmRleGVzID0gY3JlYXRlSW5WaWV3TGlzdChpblZpZXcpO1xuICAgIGlmIChpblZpZXcpIGluVmlld0NhY2hlID0gc2xpZGVJbmRleGVzO1xuICAgIGlmICghaW5WaWV3KSBub3RJblZpZXdDYWNoZSA9IHNsaWRlSW5kZXhlcztcbiAgICByZXR1cm4gc2xpZGVJbmRleGVzO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95LFxuICAgIGdldFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVTaXplcyhheGlzLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXMsIHJlYWRFZGdlR2FwLCBvd25lcldpbmRvdykge1xuICBjb25zdCB7XG4gICAgbWVhc3VyZVNpemUsXG4gICAgc3RhcnRFZGdlLFxuICAgIGVuZEVkZ2VcbiAgfSA9IGF4aXM7XG4gIGNvbnN0IHdpdGhFZGdlR2FwID0gc2xpZGVSZWN0c1swXSAmJiByZWFkRWRnZUdhcDtcbiAgY29uc3Qgc3RhcnRHYXAgPSBtZWFzdXJlU3RhcnRHYXAoKTtcbiAgY29uc3QgZW5kR2FwID0gbWVhc3VyZUVuZEdhcCgpO1xuICBjb25zdCBzbGlkZVNpemVzID0gc2xpZGVSZWN0cy5tYXAobWVhc3VyZVNpemUpO1xuICBjb25zdCBzbGlkZVNpemVzV2l0aEdhcHMgPSBtZWFzdXJlV2l0aEdhcHMoKTtcbiAgZnVuY3Rpb24gbWVhc3VyZVN0YXJ0R2FwKCkge1xuICAgIGlmICghd2l0aEVkZ2VHYXApIHJldHVybiAwO1xuICAgIGNvbnN0IHNsaWRlUmVjdCA9IHNsaWRlUmVjdHNbMF07XG4gICAgcmV0dXJuIG1hdGhBYnMoY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gc2xpZGVSZWN0W3N0YXJ0RWRnZV0pO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVFbmRHYXAoKSB7XG4gICAgaWYgKCF3aXRoRWRnZUdhcCkgcmV0dXJuIDA7XG4gICAgY29uc3Qgc3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGFycmF5TGFzdChzbGlkZXMpKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGBtYXJnaW4tJHtlbmRFZGdlfWApKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlV2l0aEdhcHMoKSB7XG4gICAgcmV0dXJuIHNsaWRlUmVjdHMubWFwKChyZWN0LCBpbmRleCwgcmVjdHMpID0+IHtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSAhaW5kZXg7XG4gICAgICBjb25zdCBpc0xhc3QgPSBhcnJheUlzTGFzdEluZGV4KHJlY3RzLCBpbmRleCk7XG4gICAgICBpZiAoaXNGaXJzdCkgcmV0dXJuIHNsaWRlU2l6ZXNbaW5kZXhdICsgc3RhcnRHYXA7XG4gICAgICBpZiAoaXNMYXN0KSByZXR1cm4gc2xpZGVTaXplc1tpbmRleF0gKyBlbmRHYXA7XG4gICAgICByZXR1cm4gcmVjdHNbaW5kZXggKyAxXVtzdGFydEVkZ2VdIC0gcmVjdFtzdGFydEVkZ2VdO1xuICAgIH0pLm1hcChtYXRoQWJzKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNsaWRlU2l6ZXMsXG4gICAgc2xpZGVTaXplc1dpdGhHYXBzLFxuICAgIHN0YXJ0R2FwLFxuICAgIGVuZEdhcFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVzVG9TY3JvbGwoYXhpcywgdmlld1NpemUsIHNsaWRlc1RvU2Nyb2xsLCBsb29wLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzdGFydEdhcCwgZW5kR2FwLCBwaXhlbFRvbGVyYW5jZSkge1xuICBjb25zdCB7XG4gICAgc3RhcnRFZGdlLFxuICAgIGVuZEVkZ2UsXG4gICAgZGlyZWN0aW9uXG4gIH0gPSBheGlzO1xuICBjb25zdCBncm91cEJ5TnVtYmVyID0gaXNOdW1iZXIoc2xpZGVzVG9TY3JvbGwpO1xuICBmdW5jdGlvbiBieU51bWJlcihhcnJheSwgZ3JvdXBTaXplKSB7XG4gICAgcmV0dXJuIGFycmF5S2V5cyhhcnJheSkuZmlsdGVyKGkgPT4gaSAlIGdyb3VwU2l6ZSA9PT0gMCkubWFwKGkgPT4gYXJyYXkuc2xpY2UoaSwgaSArIGdyb3VwU2l6ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGJ5U2l6ZShhcnJheSkge1xuICAgIGlmICghYXJyYXkubGVuZ3RoKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFycmF5S2V5cyhhcnJheSkucmVkdWNlKChncm91cHMsIHJlY3RCLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcmVjdEEgPSBhcnJheUxhc3QoZ3JvdXBzKSB8fCAwO1xuICAgICAgY29uc3QgaXNGaXJzdCA9IHJlY3RBID09PSAwO1xuICAgICAgY29uc3QgaXNMYXN0ID0gcmVjdEIgPT09IGFycmF5TGFzdEluZGV4KGFycmF5KTtcbiAgICAgIGNvbnN0IGVkZ2VBID0gY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gc2xpZGVSZWN0c1tyZWN0QV1bc3RhcnRFZGdlXTtcbiAgICAgIGNvbnN0IGVkZ2VCID0gY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gc2xpZGVSZWN0c1tyZWN0Ql1bZW5kRWRnZV07XG4gICAgICBjb25zdCBnYXBBID0gIWxvb3AgJiYgaXNGaXJzdCA/IGRpcmVjdGlvbihzdGFydEdhcCkgOiAwO1xuICAgICAgY29uc3QgZ2FwQiA9ICFsb29wICYmIGlzTGFzdCA/IGRpcmVjdGlvbihlbmRHYXApIDogMDtcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IG1hdGhBYnMoZWRnZUIgLSBnYXBCIC0gKGVkZ2VBICsgZ2FwQSkpO1xuICAgICAgaWYgKGluZGV4ICYmIGNodW5rU2l6ZSA+IHZpZXdTaXplICsgcGl4ZWxUb2xlcmFuY2UpIGdyb3Vwcy5wdXNoKHJlY3RCKTtcbiAgICAgIGlmIChpc0xhc3QpIGdyb3Vwcy5wdXNoKGFycmF5Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH0sIFtdKS5tYXAoKGN1cnJlbnRTaXplLCBpbmRleCwgZ3JvdXBzKSA9PiB7XG4gICAgICBjb25zdCBwcmV2aW91c1NpemUgPSBNYXRoLm1heChncm91cHNbaW5kZXggLSAxXSB8fCAwKTtcbiAgICAgIHJldHVybiBhcnJheS5zbGljZShwcmV2aW91c1NpemUsIGN1cnJlbnRTaXplKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBncm91cFNsaWRlcyhhcnJheSkge1xuICAgIHJldHVybiBncm91cEJ5TnVtYmVyID8gYnlOdW1iZXIoYXJyYXksIHNsaWRlc1RvU2Nyb2xsKSA6IGJ5U2l6ZShhcnJheSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBncm91cFNsaWRlc1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRW5naW5lKHJvb3QsIGNvbnRhaW5lciwgc2xpZGVzLCBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgb3B0aW9ucywgZXZlbnRIYW5kbGVyKSB7XG4gIC8vIE9wdGlvbnNcbiAgY29uc3Qge1xuICAgIGFsaWduLFxuICAgIGF4aXM6IHNjcm9sbEF4aXMsXG4gICAgZGlyZWN0aW9uLFxuICAgIHN0YXJ0SW5kZXgsXG4gICAgbG9vcCxcbiAgICBkdXJhdGlvbixcbiAgICBkcmFnRnJlZSxcbiAgICBkcmFnVGhyZXNob2xkLFxuICAgIGluVmlld1RocmVzaG9sZCxcbiAgICBzbGlkZXNUb1Njcm9sbDogZ3JvdXBTbGlkZXMsXG4gICAgc2tpcFNuYXBzLFxuICAgIGNvbnRhaW5TY3JvbGwsXG4gICAgd2F0Y2hSZXNpemUsXG4gICAgd2F0Y2hTbGlkZXMsXG4gICAgd2F0Y2hEcmFnLFxuICAgIHdhdGNoRm9jdXNcbiAgfSA9IG9wdGlvbnM7XG4gIC8vIE1lYXN1cmVtZW50c1xuICBjb25zdCBwaXhlbFRvbGVyYW5jZSA9IDI7XG4gIGNvbnN0IG5vZGVSZWN0cyA9IE5vZGVSZWN0cygpO1xuICBjb25zdCBjb250YWluZXJSZWN0ID0gbm9kZVJlY3RzLm1lYXN1cmUoY29udGFpbmVyKTtcbiAgY29uc3Qgc2xpZGVSZWN0cyA9IHNsaWRlcy5tYXAobm9kZVJlY3RzLm1lYXN1cmUpO1xuICBjb25zdCBheGlzID0gQXhpcyhzY3JvbGxBeGlzLCBkaXJlY3Rpb24pO1xuICBjb25zdCB2aWV3U2l6ZSA9IGF4aXMubWVhc3VyZVNpemUoY29udGFpbmVyUmVjdCk7XG4gIGNvbnN0IHBlcmNlbnRPZlZpZXcgPSBQZXJjZW50T2ZWaWV3KHZpZXdTaXplKTtcbiAgY29uc3QgYWxpZ25tZW50ID0gQWxpZ25tZW50KGFsaWduLCB2aWV3U2l6ZSk7XG4gIGNvbnN0IGNvbnRhaW5TbmFwcyA9ICFsb29wICYmICEhY29udGFpblNjcm9sbDtcbiAgY29uc3QgcmVhZEVkZ2VHYXAgPSBsb29wIHx8ICEhY29udGFpblNjcm9sbDtcbiAgY29uc3Qge1xuICAgIHNsaWRlU2l6ZXMsXG4gICAgc2xpZGVTaXplc1dpdGhHYXBzLFxuICAgIHN0YXJ0R2FwLFxuICAgIGVuZEdhcFxuICB9ID0gU2xpZGVTaXplcyhheGlzLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXMsIHJlYWRFZGdlR2FwLCBvd25lcldpbmRvdyk7XG4gIGNvbnN0IHNsaWRlc1RvU2Nyb2xsID0gU2xpZGVzVG9TY3JvbGwoYXhpcywgdmlld1NpemUsIGdyb3VwU2xpZGVzLCBsb29wLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzdGFydEdhcCwgZW5kR2FwLCBwaXhlbFRvbGVyYW5jZSk7XG4gIGNvbnN0IHtcbiAgICBzbmFwcyxcbiAgICBzbmFwc0FsaWduZWRcbiAgfSA9IFNjcm9sbFNuYXBzKGF4aXMsIGFsaWdubWVudCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzVG9TY3JvbGwpO1xuICBjb25zdCBjb250ZW50U2l6ZSA9IC1hcnJheUxhc3Qoc25hcHMpICsgYXJyYXlMYXN0KHNsaWRlU2l6ZXNXaXRoR2Fwcyk7XG4gIGNvbnN0IHtcbiAgICBzbmFwc0NvbnRhaW5lZCxcbiAgICBzY3JvbGxDb250YWluTGltaXRcbiAgfSA9IFNjcm9sbENvbnRhaW4odmlld1NpemUsIGNvbnRlbnRTaXplLCBzbmFwc0FsaWduZWQsIGNvbnRhaW5TY3JvbGwsIHBpeGVsVG9sZXJhbmNlKTtcbiAgY29uc3Qgc2Nyb2xsU25hcHMgPSBjb250YWluU25hcHMgPyBzbmFwc0NvbnRhaW5lZCA6IHNuYXBzQWxpZ25lZDtcbiAgY29uc3Qge1xuICAgIGxpbWl0XG4gIH0gPSBTY3JvbGxMaW1pdChjb250ZW50U2l6ZSwgc2Nyb2xsU25hcHMsIGxvb3ApO1xuICAvLyBJbmRleGVzXG4gIGNvbnN0IGluZGV4ID0gQ291bnRlcihhcnJheUxhc3RJbmRleChzY3JvbGxTbmFwcyksIHN0YXJ0SW5kZXgsIGxvb3ApO1xuICBjb25zdCBpbmRleFByZXZpb3VzID0gaW5kZXguY2xvbmUoKTtcbiAgY29uc3Qgc2xpZGVJbmRleGVzID0gYXJyYXlLZXlzKHNsaWRlcyk7XG4gIC8vIEFuaW1hdGlvblxuICBjb25zdCB1cGRhdGUgPSAoe1xuICAgIGRyYWdIYW5kbGVyLFxuICAgIHNjcm9sbEJvZHksXG4gICAgc2Nyb2xsQm91bmRzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGxvb3BcbiAgICB9XG4gIH0sIHRpbWVTdGVwKSA9PiB7XG4gICAgaWYgKCFsb29wKSBzY3JvbGxCb3VuZHMuY29uc3RyYWluKGRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCkpO1xuICAgIHNjcm9sbEJvZHkuc2Vlayh0aW1lU3RlcCk7XG4gIH07XG4gIGNvbnN0IHJlbmRlciA9ICh7XG4gICAgc2Nyb2xsQm9keSxcbiAgICB0cmFuc2xhdGUsXG4gICAgbG9jYXRpb24sXG4gICAgb2Zmc2V0TG9jYXRpb24sXG4gICAgc2Nyb2xsTG9vcGVyLFxuICAgIHNsaWRlTG9vcGVyLFxuICAgIGRyYWdIYW5kbGVyLFxuICAgIGFuaW1hdGlvbixcbiAgICBldmVudEhhbmRsZXIsXG4gICAgc2Nyb2xsQm91bmRzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGxvb3BcbiAgICB9XG4gIH0sIGxhZ09mZnNldCkgPT4ge1xuICAgIGNvbnN0IHNob3VsZFNldHRsZSA9IHNjcm9sbEJvZHkuc2V0dGxlZCgpO1xuICAgIGNvbnN0IHdpdGhpbkJvdW5kcyA9ICFzY3JvbGxCb3VuZHMuc2hvdWxkQ29uc3RyYWluKCk7XG4gICAgY29uc3QgaGFzU2V0dGxlZCA9IGxvb3AgPyBzaG91bGRTZXR0bGUgOiBzaG91bGRTZXR0bGUgJiYgd2l0aGluQm91bmRzO1xuICAgIGlmIChoYXNTZXR0bGVkICYmICFkcmFnSGFuZGxlci5wb2ludGVyRG93bigpKSB7XG4gICAgICBhbmltYXRpb24uc3RvcCgpO1xuICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NldHRsZScpO1xuICAgIH1cbiAgICBpZiAoIWhhc1NldHRsZWQpIGV2ZW50SGFuZGxlci5lbWl0KCdzY3JvbGwnKTtcbiAgICBjb25zdCBpbnRlcnBvbGF0ZWRMb2NhdGlvbiA9IGxvY2F0aW9uLmdldCgpICogbGFnT2Zmc2V0ICsgcHJldmlvdXNMb2NhdGlvbi5nZXQoKSAqICgxIC0gbGFnT2Zmc2V0KTtcbiAgICBvZmZzZXRMb2NhdGlvbi5zZXQoaW50ZXJwb2xhdGVkTG9jYXRpb24pO1xuICAgIGlmIChsb29wKSB7XG4gICAgICBzY3JvbGxMb29wZXIubG9vcChzY3JvbGxCb2R5LmRpcmVjdGlvbigpKTtcbiAgICAgIHNsaWRlTG9vcGVyLmxvb3AoKTtcbiAgICB9XG4gICAgdHJhbnNsYXRlLnRvKG9mZnNldExvY2F0aW9uLmdldCgpKTtcbiAgfTtcbiAgY29uc3QgYW5pbWF0aW9uID0gQW5pbWF0aW9ucyhvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgdGltZVN0ZXAgPT4gdXBkYXRlKGVuZ2luZSwgdGltZVN0ZXApLCBsYWdPZmZzZXQgPT4gcmVuZGVyKGVuZ2luZSwgbGFnT2Zmc2V0KSk7XG4gIC8vIFNoYXJlZFxuICBjb25zdCBmcmljdGlvbiA9IDAuNjg7XG4gIGNvbnN0IHN0YXJ0TG9jYXRpb24gPSBzY3JvbGxTbmFwc1tpbmRleC5nZXQoKV07XG4gIGNvbnN0IGxvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHByZXZpb3VzTG9jYXRpb24gPSBWZWN0b3IxRChzdGFydExvY2F0aW9uKTtcbiAgY29uc3Qgb2Zmc2V0TG9jYXRpb24gPSBWZWN0b3IxRChzdGFydExvY2F0aW9uKTtcbiAgY29uc3QgdGFyZ2V0ID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHNjcm9sbEJvZHkgPSBTY3JvbGxCb2R5KGxvY2F0aW9uLCBvZmZzZXRMb2NhdGlvbiwgcHJldmlvdXNMb2NhdGlvbiwgdGFyZ2V0LCBkdXJhdGlvbiwgZnJpY3Rpb24pO1xuICBjb25zdCBzY3JvbGxUYXJnZXQgPSBTY3JvbGxUYXJnZXQobG9vcCwgc2Nyb2xsU25hcHMsIGNvbnRlbnRTaXplLCBsaW1pdCwgdGFyZ2V0KTtcbiAgY29uc3Qgc2Nyb2xsVG8gPSBTY3JvbGxUbyhhbmltYXRpb24sIGluZGV4LCBpbmRleFByZXZpb3VzLCBzY3JvbGxCb2R5LCBzY3JvbGxUYXJnZXQsIHRhcmdldCwgZXZlbnRIYW5kbGVyKTtcbiAgY29uc3Qgc2Nyb2xsUHJvZ3Jlc3MgPSBTY3JvbGxQcm9ncmVzcyhsaW1pdCk7XG4gIGNvbnN0IGV2ZW50U3RvcmUgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IHNsaWRlc0luVmlldyA9IFNsaWRlc0luVmlldyhjb250YWluZXIsIHNsaWRlcywgZXZlbnRIYW5kbGVyLCBpblZpZXdUaHJlc2hvbGQpO1xuICBjb25zdCB7XG4gICAgc2xpZGVSZWdpc3RyeVxuICB9ID0gU2xpZGVSZWdpc3RyeShjb250YWluU25hcHMsIGNvbnRhaW5TY3JvbGwsIHNjcm9sbFNuYXBzLCBzY3JvbGxDb250YWluTGltaXQsIHNsaWRlc1RvU2Nyb2xsLCBzbGlkZUluZGV4ZXMpO1xuICBjb25zdCBzbGlkZUZvY3VzID0gU2xpZGVGb2N1cyhyb290LCBzbGlkZXMsIHNsaWRlUmVnaXN0cnksIHNjcm9sbFRvLCBzY3JvbGxCb2R5LCBldmVudFN0b3JlLCBldmVudEhhbmRsZXIsIHdhdGNoRm9jdXMpO1xuICAvLyBFbmdpbmVcbiAgY29uc3QgZW5naW5lID0ge1xuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgb3duZXJXaW5kb3csXG4gICAgZXZlbnRIYW5kbGVyLFxuICAgIGNvbnRhaW5lclJlY3QsXG4gICAgc2xpZGVSZWN0cyxcbiAgICBhbmltYXRpb24sXG4gICAgYXhpcyxcbiAgICBkcmFnSGFuZGxlcjogRHJhZ0hhbmRsZXIoYXhpcywgcm9vdCwgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIHRhcmdldCwgRHJhZ1RyYWNrZXIoYXhpcywgb3duZXJXaW5kb3cpLCBsb2NhdGlvbiwgYW5pbWF0aW9uLCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCBpbmRleCwgZXZlbnRIYW5kbGVyLCBwZXJjZW50T2ZWaWV3LCBkcmFnRnJlZSwgZHJhZ1RocmVzaG9sZCwgc2tpcFNuYXBzLCBmcmljdGlvbiwgd2F0Y2hEcmFnKSxcbiAgICBldmVudFN0b3JlLFxuICAgIHBlcmNlbnRPZlZpZXcsXG4gICAgaW5kZXgsXG4gICAgaW5kZXhQcmV2aW91cyxcbiAgICBsaW1pdCxcbiAgICBsb2NhdGlvbixcbiAgICBvZmZzZXRMb2NhdGlvbixcbiAgICBwcmV2aW91c0xvY2F0aW9uLFxuICAgIG9wdGlvbnMsXG4gICAgcmVzaXplSGFuZGxlcjogUmVzaXplSGFuZGxlcihjb250YWluZXIsIGV2ZW50SGFuZGxlciwgb3duZXJXaW5kb3csIHNsaWRlcywgYXhpcywgd2F0Y2hSZXNpemUsIG5vZGVSZWN0cyksXG4gICAgc2Nyb2xsQm9keSxcbiAgICBzY3JvbGxCb3VuZHM6IFNjcm9sbEJvdW5kcyhsaW1pdCwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgc2Nyb2xsQm9keSwgcGVyY2VudE9mVmlldyksXG4gICAgc2Nyb2xsTG9vcGVyOiBTY3JvbGxMb29wZXIoY29udGVudFNpemUsIGxpbWl0LCBvZmZzZXRMb2NhdGlvbiwgW2xvY2F0aW9uLCBvZmZzZXRMb2NhdGlvbiwgcHJldmlvdXNMb2NhdGlvbiwgdGFyZ2V0XSksXG4gICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgc2Nyb2xsU25hcExpc3Q6IHNjcm9sbFNuYXBzLm1hcChzY3JvbGxQcm9ncmVzcy5nZXQpLFxuICAgIHNjcm9sbFNuYXBzLFxuICAgIHNjcm9sbFRhcmdldCxcbiAgICBzY3JvbGxUbyxcbiAgICBzbGlkZUxvb3BlcjogU2xpZGVMb29wZXIoYXhpcywgdmlld1NpemUsIGNvbnRlbnRTaXplLCBzbGlkZVNpemVzLCBzbGlkZVNpemVzV2l0aEdhcHMsIHNuYXBzLCBzY3JvbGxTbmFwcywgb2Zmc2V0TG9jYXRpb24sIHNsaWRlcyksXG4gICAgc2xpZGVGb2N1cyxcbiAgICBzbGlkZXNIYW5kbGVyOiBTbGlkZXNIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCB3YXRjaFNsaWRlcyksXG4gICAgc2xpZGVzSW5WaWV3LFxuICAgIHNsaWRlSW5kZXhlcyxcbiAgICBzbGlkZVJlZ2lzdHJ5LFxuICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgIHRhcmdldCxcbiAgICB0cmFuc2xhdGU6IFRyYW5zbGF0ZShheGlzLCBjb250YWluZXIpXG4gIH07XG4gIHJldHVybiBlbmdpbmU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50SGFuZGxlcigpIHtcbiAgbGV0IGxpc3RlbmVycyA9IHt9O1xuICBsZXQgYXBpO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgYXBpID0gZW1ibGFBcGk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2dCkge1xuICAgIHJldHVybiBsaXN0ZW5lcnNbZXZ0XSB8fCBbXTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0KGV2dCkge1xuICAgIGdldExpc3RlbmVycyhldnQpLmZvckVhY2goZSA9PiBlKGFwaSwgZXZ0KSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gb24oZXZ0LCBjYikge1xuICAgIGxpc3RlbmVyc1tldnRdID0gZ2V0TGlzdGVuZXJzKGV2dCkuY29uY2F0KFtjYl0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIG9mZihldnQsIGNiKSB7XG4gICAgbGlzdGVuZXJzW2V2dF0gPSBnZXRMaXN0ZW5lcnMoZXZ0KS5maWx0ZXIoZSA9PiBlICE9PSBjYik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgbGlzdGVuZXJzID0ge307XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGVtaXQsXG4gICAgb2ZmLFxuICAgIG9uLFxuICAgIGNsZWFyXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWxpZ246ICdjZW50ZXInLFxuICBheGlzOiAneCcsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgc2xpZGVzOiBudWxsLFxuICBjb250YWluU2Nyb2xsOiAndHJpbVNuYXBzJyxcbiAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gIGluVmlld1RocmVzaG9sZDogMCxcbiAgYnJlYWtwb2ludHM6IHt9LFxuICBkcmFnRnJlZTogZmFsc2UsXG4gIGRyYWdUaHJlc2hvbGQ6IDEwLFxuICBsb29wOiBmYWxzZSxcbiAgc2tpcFNuYXBzOiBmYWxzZSxcbiAgZHVyYXRpb246IDI1LFxuICBzdGFydEluZGV4OiAwLFxuICBhY3RpdmU6IHRydWUsXG4gIHdhdGNoRHJhZzogdHJ1ZSxcbiAgd2F0Y2hSZXNpemU6IHRydWUsXG4gIHdhdGNoU2xpZGVzOiB0cnVlLFxuICB3YXRjaEZvY3VzOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBPcHRpb25zSGFuZGxlcihvd25lcldpbmRvdykge1xuICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uc0EsIG9wdGlvbnNCKSB7XG4gICAgcmV0dXJuIG9iamVjdHNNZXJnZURlZXAob3B0aW9uc0EsIG9wdGlvbnNCIHx8IHt9KTtcbiAgfVxuICBmdW5jdGlvbiBvcHRpb25zQXRNZWRpYShvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9uc0F0TWVkaWEgPSBvcHRpb25zLmJyZWFrcG9pbnRzIHx8IHt9O1xuICAgIGNvbnN0IG1hdGNoZWRNZWRpYU9wdGlvbnMgPSBvYmplY3RLZXlzKG9wdGlvbnNBdE1lZGlhKS5maWx0ZXIobWVkaWEgPT4gb3duZXJXaW5kb3cubWF0Y2hNZWRpYShtZWRpYSkubWF0Y2hlcykubWFwKG1lZGlhID0+IG9wdGlvbnNBdE1lZGlhW21lZGlhXSkucmVkdWNlKChhLCBtZWRpYU9wdGlvbikgPT4gbWVyZ2VPcHRpb25zKGEsIG1lZGlhT3B0aW9uKSwge30pO1xuICAgIHJldHVybiBtZXJnZU9wdGlvbnMob3B0aW9ucywgbWF0Y2hlZE1lZGlhT3B0aW9ucyk7XG4gIH1cbiAgZnVuY3Rpb24gb3B0aW9uc01lZGlhUXVlcmllcyhvcHRpb25zTGlzdCkge1xuICAgIHJldHVybiBvcHRpb25zTGlzdC5tYXAob3B0aW9ucyA9PiBvYmplY3RLZXlzKG9wdGlvbnMuYnJlYWtwb2ludHMgfHwge30pKS5yZWR1Y2UoKGFjYywgbWVkaWFRdWVyaWVzKSA9PiBhY2MuY29uY2F0KG1lZGlhUXVlcmllcyksIFtdKS5tYXAob3duZXJXaW5kb3cubWF0Y2hNZWRpYSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZXJnZU9wdGlvbnMsXG4gICAgb3B0aW9uc0F0TWVkaWEsXG4gICAgb3B0aW9uc01lZGlhUXVlcmllc1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gUGx1Z2luc0hhbmRsZXIob3B0aW9uc0hhbmRsZXIpIHtcbiAgbGV0IGFjdGl2ZVBsdWdpbnMgPSBbXTtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSwgcGx1Z2lucykge1xuICAgIGFjdGl2ZVBsdWdpbnMgPSBwbHVnaW5zLmZpbHRlcigoe1xuICAgICAgb3B0aW9uc1xuICAgIH0pID0+IG9wdGlvbnNIYW5kbGVyLm9wdGlvbnNBdE1lZGlhKG9wdGlvbnMpLmFjdGl2ZSAhPT0gZmFsc2UpO1xuICAgIGFjdGl2ZVBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmluaXQoZW1ibGFBcGksIG9wdGlvbnNIYW5kbGVyKSk7XG4gICAgcmV0dXJuIHBsdWdpbnMucmVkdWNlKChtYXAsIHBsdWdpbikgPT4gT2JqZWN0LmFzc2lnbihtYXAsIHtcbiAgICAgIFtwbHVnaW4ubmFtZV06IHBsdWdpblxuICAgIH0pLCB7fSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBhY3RpdmVQbHVnaW5zID0gYWN0aXZlUGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbi5kZXN0cm95KCkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFbWJsYUNhcm91c2VsKHJvb3QsIHVzZXJPcHRpb25zLCB1c2VyUGx1Z2lucykge1xuICBjb25zdCBvd25lckRvY3VtZW50ID0gcm9vdC5vd25lckRvY3VtZW50O1xuICBjb25zdCBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGNvbnN0IG9wdGlvbnNIYW5kbGVyID0gT3B0aW9uc0hhbmRsZXIob3duZXJXaW5kb3cpO1xuICBjb25zdCBwbHVnaW5zSGFuZGxlciA9IFBsdWdpbnNIYW5kbGVyKG9wdGlvbnNIYW5kbGVyKTtcbiAgY29uc3QgbWVkaWFIYW5kbGVycyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZXZlbnRIYW5kbGVyID0gRXZlbnRIYW5kbGVyKCk7XG4gIGNvbnN0IHtcbiAgICBtZXJnZU9wdGlvbnMsXG4gICAgb3B0aW9uc0F0TWVkaWEsXG4gICAgb3B0aW9uc01lZGlhUXVlcmllc1xuICB9ID0gb3B0aW9uc0hhbmRsZXI7XG4gIGNvbnN0IHtcbiAgICBvbixcbiAgICBvZmYsXG4gICAgZW1pdFxuICB9ID0gZXZlbnRIYW5kbGVyO1xuICBjb25zdCByZUluaXQgPSByZUFjdGl2YXRlO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGxldCBlbmdpbmU7XG4gIGxldCBvcHRpb25zQmFzZSA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgRW1ibGFDYXJvdXNlbC5nbG9iYWxPcHRpb25zKTtcbiAgbGV0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9uc0Jhc2UpO1xuICBsZXQgcGx1Z2luTGlzdCA9IFtdO1xuICBsZXQgcGx1Z2luQXBpcztcbiAgbGV0IGNvbnRhaW5lcjtcbiAgbGV0IHNsaWRlcztcbiAgZnVuY3Rpb24gc3RvcmVFbGVtZW50cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXI6IHVzZXJDb250YWluZXIsXG4gICAgICBzbGlkZXM6IHVzZXJTbGlkZXNcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjdXN0b21Db250YWluZXIgPSBpc1N0cmluZyh1c2VyQ29udGFpbmVyKSA/IHJvb3QucXVlcnlTZWxlY3Rvcih1c2VyQ29udGFpbmVyKSA6IHVzZXJDb250YWluZXI7XG4gICAgY29udGFpbmVyID0gY3VzdG9tQ29udGFpbmVyIHx8IHJvb3QuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgY3VzdG9tU2xpZGVzID0gaXNTdHJpbmcodXNlclNsaWRlcykgPyBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCh1c2VyU2xpZGVzKSA6IHVzZXJTbGlkZXM7XG4gICAgc2xpZGVzID0gW10uc2xpY2UuY2FsbChjdXN0b21TbGlkZXMgfHwgY29udGFpbmVyLmNoaWxkcmVuKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVFbmdpbmUob3B0aW9ucykge1xuICAgIGNvbnN0IGVuZ2luZSA9IEVuZ2luZShyb290LCBjb250YWluZXIsIHNsaWRlcywgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIG9wdGlvbnMsIGV2ZW50SGFuZGxlcik7XG4gICAgaWYgKG9wdGlvbnMubG9vcCAmJiAhZW5naW5lLnNsaWRlTG9vcGVyLmNhbkxvb3AoKSkge1xuICAgICAgY29uc3Qgb3B0aW9uc1dpdGhvdXRMb29wID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBsb29wOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3JlYXRlRW5naW5lKG9wdGlvbnNXaXRob3V0TG9vcCk7XG4gICAgfVxuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cbiAgZnVuY3Rpb24gYWN0aXZhdGUod2l0aE9wdGlvbnMsIHdpdGhQbHVnaW5zKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIG9wdGlvbnNCYXNlID0gbWVyZ2VPcHRpb25zKG9wdGlvbnNCYXNlLCB3aXRoT3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNBdE1lZGlhKG9wdGlvbnNCYXNlKTtcbiAgICBwbHVnaW5MaXN0ID0gd2l0aFBsdWdpbnMgfHwgcGx1Z2luTGlzdDtcbiAgICBzdG9yZUVsZW1lbnRzKCk7XG4gICAgZW5naW5lID0gY3JlYXRlRW5naW5lKG9wdGlvbnMpO1xuICAgIG9wdGlvbnNNZWRpYVF1ZXJpZXMoW29wdGlvbnNCYXNlLCAuLi5wbHVnaW5MaXN0Lm1hcCgoe1xuICAgICAgb3B0aW9uc1xuICAgIH0pID0+IG9wdGlvbnMpXSkuZm9yRWFjaChxdWVyeSA9PiBtZWRpYUhhbmRsZXJzLmFkZChxdWVyeSwgJ2NoYW5nZScsIHJlQWN0aXZhdGUpKTtcbiAgICBpZiAoIW9wdGlvbnMuYWN0aXZlKSByZXR1cm47XG4gICAgZW5naW5lLnRyYW5zbGF0ZS50byhlbmdpbmUubG9jYXRpb24uZ2V0KCkpO1xuICAgIGVuZ2luZS5hbmltYXRpb24uaW5pdCgpO1xuICAgIGVuZ2luZS5zbGlkZXNJblZpZXcuaW5pdCgpO1xuICAgIGVuZ2luZS5zbGlkZUZvY3VzLmluaXQoc2VsZik7XG4gICAgZW5naW5lLmV2ZW50SGFuZGxlci5pbml0KHNlbGYpO1xuICAgIGVuZ2luZS5yZXNpemVIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgZW5naW5lLnNsaWRlc0hhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBpZiAoZW5naW5lLm9wdGlvbnMubG9vcCkgZW5naW5lLnNsaWRlTG9vcGVyLmxvb3AoKTtcbiAgICBpZiAoY29udGFpbmVyLm9mZnNldFBhcmVudCAmJiBzbGlkZXMubGVuZ3RoKSBlbmdpbmUuZHJhZ0hhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBwbHVnaW5BcGlzID0gcGx1Z2luc0hhbmRsZXIuaW5pdChzZWxmLCBwbHVnaW5MaXN0KTtcbiAgfVxuICBmdW5jdGlvbiByZUFjdGl2YXRlKHdpdGhPcHRpb25zLCB3aXRoUGx1Z2lucykge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBzZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgICBkZUFjdGl2YXRlKCk7XG4gICAgYWN0aXZhdGUobWVyZ2VPcHRpb25zKHtcbiAgICAgIHN0YXJ0SW5kZXhcbiAgICB9LCB3aXRoT3B0aW9ucyksIHdpdGhQbHVnaW5zKTtcbiAgICBldmVudEhhbmRsZXIuZW1pdCgncmVJbml0Jyk7XG4gIH1cbiAgZnVuY3Rpb24gZGVBY3RpdmF0ZSgpIHtcbiAgICBlbmdpbmUuZHJhZ0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5ldmVudFN0b3JlLmNsZWFyKCk7XG4gICAgZW5naW5lLnRyYW5zbGF0ZS5jbGVhcigpO1xuICAgIGVuZ2luZS5zbGlkZUxvb3Blci5jbGVhcigpO1xuICAgIGVuZ2luZS5yZXNpemVIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBlbmdpbmUuc2xpZGVzSGFuZGxlci5kZXN0cm95KCk7XG4gICAgZW5naW5lLnNsaWRlc0luVmlldy5kZXN0cm95KCk7XG4gICAgZW5naW5lLmFuaW1hdGlvbi5kZXN0cm95KCk7XG4gICAgcGx1Z2luc0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIG1lZGlhSGFuZGxlcnMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICAgIG1lZGlhSGFuZGxlcnMuY2xlYXIoKTtcbiAgICBkZUFjdGl2YXRlKCk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICBldmVudEhhbmRsZXIuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxUbyhpbmRleCwganVtcCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKCFvcHRpb25zLmFjdGl2ZSB8fCBkZXN0cm95ZWQpIHJldHVybjtcbiAgICBlbmdpbmUuc2Nyb2xsQm9keS51c2VCYXNlRnJpY3Rpb24oKS51c2VEdXJhdGlvbihqdW1wID09PSB0cnVlID8gMCA6IG9wdGlvbnMuZHVyYXRpb24pO1xuICAgIGVuZ2luZS5zY3JvbGxUby5pbmRleChpbmRleCwgZGlyZWN0aW9uIHx8IDApO1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbE5leHQoanVtcCkge1xuICAgIGNvbnN0IG5leHQgPSBlbmdpbmUuaW5kZXguYWRkKDEpLmdldCgpO1xuICAgIHNjcm9sbFRvKG5leHQsIGp1bXAsIC0xKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxQcmV2KGp1bXApIHtcbiAgICBjb25zdCBwcmV2ID0gZW5naW5lLmluZGV4LmFkZCgtMSkuZ2V0KCk7XG4gICAgc2Nyb2xsVG8ocHJldiwganVtcCwgMSk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuU2Nyb2xsTmV4dCgpIHtcbiAgICBjb25zdCBuZXh0ID0gZW5naW5lLmluZGV4LmFkZCgxKS5nZXQoKTtcbiAgICByZXR1cm4gbmV4dCAhPT0gc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuU2Nyb2xsUHJldigpIHtcbiAgICBjb25zdCBwcmV2ID0gZW5naW5lLmluZGV4LmFkZCgtMSkuZ2V0KCk7XG4gICAgcmV0dXJuIHByZXYgIT09IHNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFNuYXBMaXN0KCkge1xuICAgIHJldHVybiBlbmdpbmUuc2Nyb2xsU25hcExpc3Q7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsUHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zY3JvbGxQcm9ncmVzcy5nZXQoZW5naW5lLmxvY2F0aW9uLmdldCgpKTtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RlZFNjcm9sbFNuYXAoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5pbmRleC5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2aW91c1Njcm9sbFNuYXAoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5pbmRleFByZXZpb3VzLmdldCgpO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlc0luVmlldygpIHtcbiAgICByZXR1cm4gZW5naW5lLnNsaWRlc0luVmlldy5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZXNOb3RJblZpZXcoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zbGlkZXNJblZpZXcuZ2V0KGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBwbHVnaW5zKCkge1xuICAgIHJldHVybiBwbHVnaW5BcGlzO1xuICB9XG4gIGZ1bmN0aW9uIGludGVybmFsRW5naW5lKCkge1xuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cbiAgZnVuY3Rpb24gcm9vdE5vZGUoKSB7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cbiAgZnVuY3Rpb24gY29udGFpbmVyTm9kZSgpIHtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlTm9kZXMoKSB7XG4gICAgcmV0dXJuIHNsaWRlcztcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNhblNjcm9sbE5leHQsXG4gICAgY2FuU2Nyb2xsUHJldixcbiAgICBjb250YWluZXJOb2RlLFxuICAgIGludGVybmFsRW5naW5lLFxuICAgIGRlc3Ryb3ksXG4gICAgb2ZmLFxuICAgIG9uLFxuICAgIGVtaXQsXG4gICAgcGx1Z2lucyxcbiAgICBwcmV2aW91c1Njcm9sbFNuYXAsXG4gICAgcmVJbml0LFxuICAgIHJvb3ROb2RlLFxuICAgIHNjcm9sbE5leHQsXG4gICAgc2Nyb2xsUHJldixcbiAgICBzY3JvbGxQcm9ncmVzcyxcbiAgICBzY3JvbGxTbmFwTGlzdCxcbiAgICBzY3JvbGxUbyxcbiAgICBzZWxlY3RlZFNjcm9sbFNuYXAsXG4gICAgc2xpZGVOb2RlcyxcbiAgICBzbGlkZXNJblZpZXcsXG4gICAgc2xpZGVzTm90SW5WaWV3XG4gIH07XG4gIGFjdGl2YXRlKHVzZXJPcHRpb25zLCB1c2VyUGx1Z2lucyk7XG4gIHNldFRpbWVvdXQoKCkgPT4gZXZlbnRIYW5kbGVyLmVtaXQoJ2luaXQnKSwgMCk7XG4gIHJldHVybiBzZWxmO1xufVxuRW1ibGFDYXJvdXNlbC5nbG9iYWxPcHRpb25zID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgeyBFbWJsYUNhcm91c2VsIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmxhLWNhcm91c2VsLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc051bWJlciIsInN1YmplY3QiLCJpc1N0cmluZyIsImlzQm9vbGVhbiIsImlzT2JqZWN0IiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwibWF0aEFicyIsIm4iLCJNYXRoIiwiYWJzIiwibWF0aFNpZ24iLCJzaWduIiwiZGVsdGFBYnMiLCJ2YWx1ZUIiLCJ2YWx1ZUEiLCJmYWN0b3JBYnMiLCJkaWZmIiwiYXJyYXlLZXlzIiwiYXJyYXkiLCJvYmplY3RLZXlzIiwibWFwIiwiTnVtYmVyIiwiYXJyYXlMYXN0IiwiYXJyYXlMYXN0SW5kZXgiLCJtYXgiLCJsZW5ndGgiLCJhcnJheUlzTGFzdEluZGV4IiwiaW5kZXgiLCJhcnJheUZyb21OdW1iZXIiLCJzdGFydEF0IiwiQXJyYXkiLCJmcm9tIiwiXyIsImkiLCJvYmplY3QiLCJrZXlzIiwib2JqZWN0c01lcmdlRGVlcCIsIm9iamVjdEEiLCJvYmplY3RCIiwicmVkdWNlIiwibWVyZ2VkT2JqZWN0cyIsImN1cnJlbnRPYmplY3QiLCJmb3JFYWNoIiwia2V5IiwiYXJlT2JqZWN0cyIsImlzTW91c2VFdmVudCIsImV2dCIsIm93bmVyV2luZG93IiwiTW91c2VFdmVudCIsIkFsaWdubWVudCIsImFsaWduIiwidmlld1NpemUiLCJwcmVkZWZpbmVkIiwic3RhcnQiLCJjZW50ZXIiLCJlbmQiLCJtZWFzdXJlIiwic2VsZiIsIkV2ZW50U3RvcmUiLCJsaXN0ZW5lcnMiLCJhZGQiLCJub2RlIiwidHlwZSIsImhhbmRsZXIiLCJvcHRpb25zIiwicGFzc2l2ZSIsInJlbW92ZUxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsZWdhY3lNZWRpYVF1ZXJ5TGlzdCIsImFkZExpc3RlbmVyIiwicHVzaCIsImNsZWFyIiwiZmlsdGVyIiwicmVtb3ZlIiwiQW5pbWF0aW9ucyIsIm93bmVyRG9jdW1lbnQiLCJ1cGRhdGUiLCJyZW5kZXIiLCJkb2N1bWVudFZpc2libGVIYW5kbGVyIiwidGltZVN0ZXAiLCJsYXN0VGltZVN0YW1wIiwibGFnIiwiYW5pbWF0aW9uRnJhbWUiLCJpbml0IiwiaGlkZGVuIiwicmVzZXQiLCJkZXN0cm95Iiwic3RvcCIsImFuaW1hdGUiLCJ0aW1lU3RhbXAiLCJlbGFwc2VkIiwibGFnT2Zmc2V0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJBeGlzIiwiYXhpcyIsImNvbnRlbnREaXJlY3Rpb24iLCJpc1JpZ2h0VG9MZWZ0IiwiaXNWZXJ0aWNhbCIsInNjcm9sbCIsImNyb3NzIiwic3RhcnRFZGdlIiwiZ2V0U3RhcnRFZGdlIiwiZW5kRWRnZSIsImdldEVuZEVkZ2UiLCJtZWFzdXJlU2l6ZSIsIm5vZGVSZWN0IiwiaGVpZ2h0Iiwid2lkdGgiLCJkaXJlY3Rpb24iLCJMaW1pdCIsIm1pbiIsInJlYWNoZWRNaW4iLCJyZWFjaGVkTWF4IiwicmVhY2hlZEFueSIsImNvbnN0cmFpbiIsInJlbW92ZU9mZnNldCIsImNlaWwiLCJDb3VudGVyIiwibG9vcCIsImxvb3BFbmQiLCJjb3VudGVyIiwid2l0aGluTGltaXQiLCJnZXQiLCJzZXQiLCJjbG9uZSIsIkRyYWdIYW5kbGVyIiwicm9vdE5vZGUiLCJ0YXJnZXQiLCJkcmFnVHJhY2tlciIsImxvY2F0aW9uIiwiYW5pbWF0aW9uIiwic2Nyb2xsVG8iLCJzY3JvbGxCb2R5Iiwic2Nyb2xsVGFyZ2V0IiwiZXZlbnRIYW5kbGVyIiwicGVyY2VudE9mVmlldyIsImRyYWdGcmVlIiwiZHJhZ1RocmVzaG9sZCIsInNraXBTbmFwcyIsImJhc2VGcmljdGlvbiIsIndhdGNoRHJhZyIsImNyb3NzQXhpcyIsImZvY3VzTm9kZXMiLCJub25QYXNzaXZlRXZlbnQiLCJpbml0RXZlbnRzIiwiZHJhZ0V2ZW50cyIsImdvVG9OZXh0VGhyZXNob2xkIiwic25hcEZvcmNlQm9vc3QiLCJtb3VzZSIsInRvdWNoIiwiZnJlZUZvcmNlQm9vc3QiLCJiYXNlU3BlZWQiLCJpc01vdmluZyIsInN0YXJ0U2Nyb2xsIiwic3RhcnRDcm9zcyIsInBvaW50ZXJJc0Rvd24iLCJwcmV2ZW50U2Nyb2xsIiwicHJldmVudENsaWNrIiwiaXNNb3VzZSIsImVtYmxhQXBpIiwiZG93bklmQWxsb3dlZCIsImRvd24iLCJwcmV2ZW50RGVmYXVsdCIsInVuZGVmaW5lZCIsInVwIiwiY2xpY2siLCJhZGREcmFnRXZlbnRzIiwibW92ZSIsImlzRm9jdXNOb2RlIiwibm9kZU5hbWUiLCJpbmNsdWRlcyIsImZvcmNlQm9vc3QiLCJib29zdCIsImFsbG93ZWRGb3JjZSIsImZvcmNlIiwidGFyZ2V0Q2hhbmdlZCIsIm5leHQiLCJiYXNlRm9yY2UiLCJieURpc3RhbmNlIiwiZGlzdGFuY2UiLCJieUluZGV4IiwiaXNNb3VzZUV2dCIsImJ1dHRvbnMiLCJidXR0b24iLCJwb2ludGVyRG93biIsInVzZUZyaWN0aW9uIiwidXNlRHVyYXRpb24iLCJyZWFkUG9pbnQiLCJlbWl0IiwiaXNUb3VjaEV2dCIsInRvdWNoZXMiLCJsYXN0U2Nyb2xsIiwibGFzdENyb3NzIiwiZGlmZlNjcm9sbCIsImRpZmZDcm9zcyIsImNhbmNlbGFibGUiLCJwb2ludGVyTW92ZSIsImN1cnJlbnRMb2NhdGlvbiIsInJhd0ZvcmNlIiwicG9pbnRlclVwIiwiZm9yY2VGYWN0b3IiLCJzcGVlZCIsImZyaWN0aW9uIiwic3RvcFByb3BhZ2F0aW9uIiwiRHJhZ1RyYWNrZXIiLCJsb2dJbnRlcnZhbCIsInN0YXJ0RXZlbnQiLCJsYXN0RXZlbnQiLCJyZWFkVGltZSIsImV2dEF4aXMiLCJwcm9wZXJ0eSIsImNvb3JkIiwiZXhwaXJlZCIsImRpZmZEcmFnIiwiZGlmZlRpbWUiLCJpc0ZsaWNrIiwiTm9kZVJlY3RzIiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiUGVyY2VudE9mVmlldyIsIlJlc2l6ZUhhbmRsZXIiLCJjb250YWluZXIiLCJzbGlkZXMiLCJ3YXRjaFJlc2l6ZSIsIm5vZGVSZWN0cyIsIm9ic2VydmVOb2RlcyIsImNvbmNhdCIsInJlc2l6ZU9ic2VydmVyIiwiY29udGFpbmVyU2l6ZSIsInNsaWRlU2l6ZXMiLCJkZXN0cm95ZWQiLCJyZWFkU2l6ZSIsImRlZmF1bHRDYWxsYmFjayIsImVudHJpZXMiLCJlbnRyeSIsImlzQ29udGFpbmVyIiwic2xpZGVJbmRleCIsImluZGV4T2YiLCJsYXN0U2l6ZSIsIm5ld1NpemUiLCJkaWZmU2l6ZSIsInJlSW5pdCIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJTY3JvbGxCb2R5Iiwib2Zmc2V0TG9jYXRpb24iLCJwcmV2aW91c0xvY2F0aW9uIiwiYmFzZUR1cmF0aW9uIiwiYm9keVZlbG9jaXR5Iiwic2Nyb2xsRGlyZWN0aW9uIiwic2Nyb2xsRHVyYXRpb24iLCJzY3JvbGxGcmljdGlvbiIsInJhd0xvY2F0aW9uIiwicmF3TG9jYXRpb25QcmV2aW91cyIsInNlZWsiLCJmaXhlZERlbHRhVGltZVNlY29uZHMiLCJkdXJhdGlvbiIsImlzSW5zdGFudCIsImRpcmVjdGlvbkRpZmYiLCJzZXR0bGVkIiwidmVsb2NpdHkiLCJ1c2VCYXNlRHVyYXRpb24iLCJ1c2VCYXNlRnJpY3Rpb24iLCJTY3JvbGxCb3VuZHMiLCJsaW1pdCIsInB1bGxCYWNrVGhyZXNob2xkIiwiZWRnZU9mZnNldFRvbGVyYW5jZSIsImZyaWN0aW9uTGltaXQiLCJkaXNhYmxlZCIsInNob3VsZENvbnN0cmFpbiIsImVkZ2UiLCJkaWZmVG9FZGdlIiwiZGlmZlRvVGFyZ2V0Iiwic3VidHJhY3QiLCJ0b2dnbGVBY3RpdmUiLCJhY3RpdmUiLCJTY3JvbGxDb250YWluIiwiY29udGVudFNpemUiLCJzbmFwc0FsaWduZWQiLCJjb250YWluU2Nyb2xsIiwicGl4ZWxUb2xlcmFuY2UiLCJzY3JvbGxCb3VuZHMiLCJzbmFwc0JvdW5kZWQiLCJtZWFzdXJlQm91bmRlZCIsInNjcm9sbENvbnRhaW5MaW1pdCIsImZpbmRTY3JvbGxDb250YWluTGltaXQiLCJzbmFwc0NvbnRhaW5lZCIsIm1lYXN1cmVDb250YWluZWQiLCJ1c2VQaXhlbFRvbGVyYW5jZSIsImJvdW5kIiwic25hcCIsInN0YXJ0U25hcCIsImVuZFNuYXAiLCJsYXN0SW5kZXhPZiIsInNuYXBBbGlnbmVkIiwiaXNGaXJzdCIsImlzTGFzdCIsInNjcm9sbEJvdW5kIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJzbGljZSIsIlNjcm9sbExpbWl0Iiwic2Nyb2xsU25hcHMiLCJTY3JvbGxMb29wZXIiLCJ2ZWN0b3JzIiwiam9pbnRTYWZldHkiLCJzaG91bGRMb29wIiwibG9vcERpc3RhbmNlIiwidiIsIlNjcm9sbFByb2dyZXNzIiwiU2Nyb2xsU25hcHMiLCJhbGlnbm1lbnQiLCJjb250YWluZXJSZWN0Iiwic2xpZGVSZWN0cyIsInNsaWRlc1RvU2Nyb2xsIiwiZ3JvdXBTbGlkZXMiLCJhbGlnbm1lbnRzIiwibWVhc3VyZVNpemVzIiwic25hcHMiLCJtZWFzdXJlVW5hbGlnbmVkIiwibWVhc3VyZUFsaWduZWQiLCJyZWN0cyIsInJlY3QiLCJnIiwiU2xpZGVSZWdpc3RyeSIsImNvbnRhaW5TbmFwcyIsInNsaWRlSW5kZXhlcyIsInNsaWRlUmVnaXN0cnkiLCJjcmVhdGVTbGlkZVJlZ2lzdHJ5IiwiZ3JvdXBlZFNsaWRlSW5kZXhlcyIsImRvTm90Q29udGFpbiIsImdyb3VwIiwiZ3JvdXBzIiwicmFuZ2UiLCJTY3JvbGxUYXJnZXQiLCJ0YXJnZXRWZWN0b3IiLCJtaW5EaXN0YW5jZSIsImRpc3RhbmNlcyIsInNvcnQiLCJhIiwiYiIsImZpbmRUYXJnZXRTbmFwIiwiYXNjRGlmZnNUb1NuYXBzIiwic2hvcnRjdXQiLCJkMSIsImQyIiwidGFyZ2V0cyIsIm1hdGNoaW5nVGFyZ2V0cyIsInQiLCJkaWZmVG9TbmFwIiwidGFyZ2V0U25hcERpc3RhbmNlIiwicmVhY2hlZEJvdW5kIiwic25hcERpc3RhbmNlIiwiU2Nyb2xsVG8iLCJpbmRleEN1cnJlbnQiLCJpbmRleFByZXZpb3VzIiwiZGlzdGFuY2VEaWZmIiwiaW5kZXhEaWZmIiwidGFyZ2V0SW5kZXgiLCJTbGlkZUZvY3VzIiwicm9vdCIsImV2ZW50U3RvcmUiLCJ3YXRjaEZvY3VzIiwiZm9jdXNMaXN0ZW5lck9wdGlvbnMiLCJjYXB0dXJlIiwibGFzdFRhYlByZXNzVGltZSIsIm5vd1RpbWUiLCJEYXRlIiwiZ2V0VGltZSIsInNjcm9sbExlZnQiLCJmaW5kSW5kZXgiLCJkb2N1bWVudCIsInJlZ2lzdGVyVGFiUHJlc3MiLCJzbGlkZSIsImV2ZW50IiwiY29kZSIsIlZlY3RvcjFEIiwiaW5pdGlhbFZhbHVlIiwidmFsdWUiLCJub3JtYWxpemVJbnB1dCIsIlRyYW5zbGF0ZSIsInRyYW5zbGF0ZSIsIngiLCJ5IiwiY29udGFpbmVyU3R5bGUiLCJzdHlsZSIsInRvIiwidHJhbnNmb3JtIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiU2xpZGVMb29wZXIiLCJzbGlkZVNpemVzV2l0aEdhcHMiLCJyb3VuZGluZ1NhZmV0eSIsImFzY0l0ZW1zIiwiZGVzY0l0ZW1zIiwicmV2ZXJzZSIsImxvb3BQb2ludHMiLCJzdGFydFBvaW50cyIsImVuZFBvaW50cyIsInJlbW92ZVNsaWRlU2l6ZXMiLCJpbmRleGVzIiwic2xpZGVzSW5HYXAiLCJnYXAiLCJyZW1haW5pbmdHYXAiLCJmaW5kU2xpZGVCb3VuZHMiLCJmaW5kTG9vcFBvaW50cyIsImlzRW5kRWRnZSIsInNsaWRlQm91bmRzIiwiaW5pdGlhbCIsImFsdGVyZWQiLCJib3VuZEVkZ2UiLCJsb29wUG9pbnQiLCJzbGlkZUxvY2F0aW9uIiwiY2FuTG9vcCIsImV2ZXJ5Iiwib3RoZXJJbmRleGVzIiwic2hpZnRMb2NhdGlvbiIsIlNsaWRlc0hhbmRsZXIiLCJ3YXRjaFNsaWRlcyIsIm11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnMiLCJtdXRhdGlvbiIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjaGlsZExpc3QiLCJTbGlkZXNJblZpZXciLCJ0aHJlc2hvbGQiLCJpbnRlcnNlY3Rpb25FbnRyeU1hcCIsImluVmlld0NhY2hlIiwibm90SW5WaWV3Q2FjaGUiLCJpbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicGFyZW50RWxlbWVudCIsImNyZWF0ZUluVmlld0xpc3QiLCJpblZpZXciLCJsaXN0IiwicGFyc2VJbnQiLCJpc0ludGVyc2VjdGluZyIsImluVmlld01hdGNoIiwibm90SW5WaWV3TWF0Y2giLCJTbGlkZVNpemVzIiwicmVhZEVkZ2VHYXAiLCJ3aXRoRWRnZUdhcCIsInN0YXJ0R2FwIiwibWVhc3VyZVN0YXJ0R2FwIiwiZW5kR2FwIiwibWVhc3VyZUVuZEdhcCIsIm1lYXN1cmVXaXRoR2FwcyIsInNsaWRlUmVjdCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiU2xpZGVzVG9TY3JvbGwiLCJncm91cEJ5TnVtYmVyIiwiYnlOdW1iZXIiLCJncm91cFNpemUiLCJieVNpemUiLCJyZWN0QiIsInJlY3RBIiwiZWRnZUEiLCJlZGdlQiIsImdhcEEiLCJnYXBCIiwiY2h1bmtTaXplIiwiY3VycmVudFNpemUiLCJwcmV2aW91c1NpemUiLCJFbmdpbmUiLCJzY3JvbGxBeGlzIiwic3RhcnRJbmRleCIsImluVmlld1RocmVzaG9sZCIsImRyYWdIYW5kbGVyIiwic2Nyb2xsTG9vcGVyIiwic2xpZGVMb29wZXIiLCJzaG91bGRTZXR0bGUiLCJ3aXRoaW5Cb3VuZHMiLCJoYXNTZXR0bGVkIiwiaW50ZXJwb2xhdGVkTG9jYXRpb24iLCJlbmdpbmUiLCJzdGFydExvY2F0aW9uIiwic2Nyb2xsUHJvZ3Jlc3MiLCJzbGlkZXNJblZpZXciLCJzbGlkZUZvY3VzIiwicmVzaXplSGFuZGxlciIsInNjcm9sbFNuYXBMaXN0Iiwic2xpZGVzSGFuZGxlciIsIkV2ZW50SGFuZGxlciIsImFwaSIsImdldExpc3RlbmVycyIsImUiLCJvbiIsImNiIiwib2ZmIiwiZGVmYXVsdE9wdGlvbnMiLCJicmVha3BvaW50cyIsIk9wdGlvbnNIYW5kbGVyIiwibWVyZ2VPcHRpb25zIiwib3B0aW9uc0EiLCJvcHRpb25zQiIsIm9wdGlvbnNBdE1lZGlhIiwibWF0Y2hlZE1lZGlhT3B0aW9ucyIsIm1lZGlhIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJtZWRpYU9wdGlvbiIsIm9wdGlvbnNNZWRpYVF1ZXJpZXMiLCJvcHRpb25zTGlzdCIsImFjYyIsIm1lZGlhUXVlcmllcyIsIlBsdWdpbnNIYW5kbGVyIiwib3B0aW9uc0hhbmRsZXIiLCJhY3RpdmVQbHVnaW5zIiwicGx1Z2lucyIsInBsdWdpbiIsImFzc2lnbiIsIm5hbWUiLCJFbWJsYUNhcm91c2VsIiwidXNlck9wdGlvbnMiLCJ1c2VyUGx1Z2lucyIsImRlZmF1bHRWaWV3IiwicGx1Z2luc0hhbmRsZXIiLCJtZWRpYUhhbmRsZXJzIiwicmVBY3RpdmF0ZSIsIm9wdGlvbnNCYXNlIiwiZ2xvYmFsT3B0aW9ucyIsInBsdWdpbkxpc3QiLCJwbHVnaW5BcGlzIiwic3RvcmVFbGVtZW50cyIsInVzZXJDb250YWluZXIiLCJ1c2VyU2xpZGVzIiwiY3VzdG9tQ29udGFpbmVyIiwicXVlcnlTZWxlY3RvciIsImNoaWxkcmVuIiwiY3VzdG9tU2xpZGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImNyZWF0ZUVuZ2luZSIsIm9wdGlvbnNXaXRob3V0TG9vcCIsImFjdGl2YXRlIiwid2l0aE9wdGlvbnMiLCJ3aXRoUGx1Z2lucyIsInF1ZXJ5Iiwib2Zmc2V0UGFyZW50Iiwic2VsZWN0ZWRTY3JvbGxTbmFwIiwiZGVBY3RpdmF0ZSIsImp1bXAiLCJzY3JvbGxOZXh0Iiwic2Nyb2xsUHJldiIsInByZXYiLCJjYW5TY3JvbGxOZXh0IiwiY2FuU2Nyb2xsUHJldiIsInByZXZpb3VzU2Nyb2xsU25hcCIsInNsaWRlc05vdEluVmlldyIsImludGVybmFsRW5naW5lIiwiY29udGFpbmVyTm9kZSIsInNsaWRlTm9kZXMiLCJzZXRUaW1lb3V0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/embla-carousel/esm/embla-carousel.esm.js\n");

/***/ })

};
;